import type { Location, Size, Region } from '@applitools/utils';
import { type SpecType, type SpecDriver } from './spec-driver';
import { type Context } from './context';
import { type Selector, type CommonSelector } from './selector';
export type ElementReference<T extends SpecType> = T['element'] | Selector<T>;
type ElementState = {
    contentSize?: Size;
    scrollOffset?: Location;
    transforms?: any;
    attributes?: Record<string, string | Error>;
    touchPadding?: number;
    containedElements?: Map<any, boolean>;
};
type ElementOptions<T extends SpecType> = {
    spec: SpecDriver<T>;
    context?: Context<T>;
} & ({
    element: T['element'];
    selector?: Selector<T>;
    index?: number;
} | {
    selector: Selector<T>;
    index?: number;
});
export declare class Element<T extends SpecType> {
    private _target?;
    private _context?;
    private _selector?;
    private _commonSelector;
    private _index?;
    private _state;
    private _originalOverflow;
    protected readonly _spec: SpecDriver<T>;
    constructor(options: ElementOptions<T>);
    get logger(): import("@applitools/logger").Logger;
    get target(): NonNullable<T["element"]>;
    get selector(): Selector<T> | undefined;
    get commonSelector(): CommonSelector | null;
    get index(): number | undefined;
    get context(): Context<T>;
    get driver(): import("./driver").Driver<T>;
    get isRef(): boolean;
    equals(element: Element<T> | T['element']): Promise<boolean>;
    contains(innerElement: Element<T> | T['element']): Promise<boolean>;
    init(context: Context<T>): Promise<this>;
    getRegion(): Promise<Region>;
    getClientRegion(): Promise<Region>;
    getContentRegion(options?: {
        lazyLoad?: {
            scrollLength?: number;
            waitingTime?: number;
            maxAmountToScroll?: number;
        };
    }): Promise<Region>;
    getContentSize(options?: {
        lazyLoad?: {
            scrollLength?: number;
            waitingTime?: number;
            maxAmountToScroll?: number;
        };
    }): Promise<Size>;
    isPager(): Promise<boolean>;
    isScrollable(): Promise<boolean>;
    isRoot(): Promise<boolean>;
    getShadowRoot(): Promise<T['element'] | null>;
    getTouchPadding(): Promise<number>;
    getText(): Promise<string>;
    getAttribute(name: string): Promise<string>;
    setAttribute(name: string, value: string): Promise<void>;
    scrollTo(offset: Location, options?: {
        force: boolean;
    }): Promise<Location>;
    translateTo(offset: Location): Promise<Location>;
    getScrollOffset(): Promise<Location>;
    getTranslateOffset(): Promise<Location>;
    getInnerOffset(): Promise<Location>;
    click(): Promise<void>;
    type(value: string): Promise<void>;
    preserveState(): Promise<ElementState>;
    restoreState(state?: ElementState): Promise<void>;
    hideScrollbars(): Promise<void>;
    restoreScrollbars(): Promise<void>;
    refresh(freshTarget?: T['element']): Promise<boolean>;
    withRefresh<TResult>(operation: (...args: any[]) => TResult): Promise<TResult>;
    toJSON(): T['element'];
}
export declare function isElementReference<T extends SpecType>(reference: any, spec?: SpecDriver<T>): reference is ElementReference<T>;
export {};
