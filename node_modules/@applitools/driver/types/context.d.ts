import type { Location, Size, Region } from '@applitools/utils';
import type { Cookie } from './types';
import { type SpecType, type SpecDriver, type WaitOptions } from './spec-driver';
import { type Driver } from './driver';
import { type Selector } from './selector';
import { Element, type ElementReference } from './element';
export type ContextReference<T extends SpecType> = Element<T> | ElementReference<T> | string | number;
export type NestedContextReference<T extends SpecType> = {
    reference: ContextReference<T>;
    scrollingElement?: Element<T>;
    parent?: Context<T> | ContextReference<T> | NestedContextReference<T>;
};
type ContextOptions<T extends SpecType> = {
    spec: SpecDriver<T>;
    context?: T['context'];
    driver?: Driver<T>;
    parent?: Context<T>;
    reference?: ContextReference<T>;
    element?: Element<T>;
    scrollingElement?: Element<T>;
};
export declare class Context<T extends SpecType> {
    private _target?;
    private _driver?;
    private _parent?;
    private _element?;
    private _reference?;
    private _scrollingElement?;
    private _state;
    private _isReference;
    protected readonly _spec: SpecDriver<T>;
    constructor(options: ContextOptions<T>);
    get logger(): import("@applitools/logger").Logger;
    get target(): T['driver'];
    get driver(): Driver<T>;
    get parent(): Context<T> | null;
    get main(): Context<T>;
    get path(): Context<T>[];
    get isMain(): boolean;
    get isCurrent(): boolean;
    get isInitialized(): boolean;
    get isRef(): boolean;
    private _findElements;
    init(): Promise<this>;
    focus(): Promise<this>;
    equals(context: Context<T> | Element<T>): Promise<boolean>;
    context(reference: ContextReference<T> | NestedContextReference<T>): Promise<Context<T>>;
    element(elementOrSelector: ElementReference<T>): Promise<Element<T> | null>;
    elements(selectorOrElement: ElementReference<T>): Promise<Element<T>[]>;
    waitFor(selector: Selector<T>, options?: WaitOptions): Promise<Element<T> | null>;
    execute(script: ((args: any) => any) | string, arg?: any): Promise<any>;
    executePoll(script: ((arg: any) => any) | string | {
        main: ((arg: any) => any) | string;
        poll: ((arg: any) => any) | string;
    }, arg?: any | {
        main: any;
        poll: any;
        executionTimeout?: number;
        pollTimeout?: number;
    }): Promise<any>;
    getContextElement(): Promise<Element<T> | null>;
    getScrollingElement(): Promise<Element<T> | null>;
    setScrollingElement(scrollingElement: Element<T> | ElementReference<T> | undefined | null): Promise<void>;
    blurElement(element?: Element<T>): Promise<T['element'] | null>;
    focusElement(element: Element<T>): Promise<any>;
    getRegion(): Promise<Region>;
    getClientRegion(): Promise<Region>;
    getScrollingRegion(): Promise<Region>;
    getContentSize(): Promise<Size>;
    getInnerOffset(): Promise<Location>;
    getLocationInMainContext(): Promise<Location>;
    getLocationInViewport(): Promise<Location>;
    getRegionInViewport(region: Region): Promise<Region>;
    getCookies(): Promise<Cookie[]>;
    private preserveInnerOffset;
    private preserveContextRegions;
    private preserveScrollingRegion;
}
export {};
