"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = exports.TargetAutomation = exports.TargetImage = exports.CheckSettingsAutomationFluent = exports.CheckSettingsImageFluent = exports.CheckSettingsBaseFluent = void 0;
const AccessibilityRegionType_1 = require("../enums/AccessibilityRegionType");
const MatchLevel_1 = require("../enums/MatchLevel");
const utils = __importStar(require("@applitools/utils"));
class CheckSettingsBaseFluent {
    constructor(settings) {
        this._settings = {};
        this._settings = utils.types.instanceOf(settings, CheckSettingsBaseFluent) ? settings.toObject() : settings !== null && settings !== void 0 ? settings : {};
    }
    region(region) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.region = region;
        return this;
    }
    name(name) {
        this._settings.name = name;
        return this;
    }
    withName(name) {
        return this.name(name);
    }
    ignoreRegion(region) {
        if (!this._settings.ignoreRegions)
            this._settings.ignoreRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.ignoreRegions.push(region);
        return this;
    }
    ignoreRegions(...regions) {
        regions.forEach(region => this.ignoreRegion(region));
        return this;
    }
    /** @deprecated */
    ignore(region) {
        return this.ignoreRegion(region);
    }
    /** @deprecated */
    ignores(...regions) {
        return this.ignoreRegions(...regions);
    }
    layoutRegion(region) {
        if (!this._settings.layoutRegions)
            this._settings.layoutRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.layoutRegions.push(region);
        return this;
    }
    layoutRegions(...regions) {
        regions.forEach(region => this.layoutRegion(region));
        return this;
    }
    strictRegion(region) {
        if (!this._settings.strictRegions)
            this._settings.strictRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.strictRegions.push(region);
        return this;
    }
    strictRegions(...regions) {
        regions.forEach(region => this.strictRegion(region));
        return this;
    }
    contentRegion(region) {
        if (!this._settings.contentRegions)
            this._settings.contentRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.contentRegions.push(region);
        return this;
    }
    contentRegions(...regions) {
        regions.forEach(region => this.contentRegion(region));
        return this;
    }
    floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        let floatingRegion;
        if (utils.types.has(region, 'region')) {
            const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...rest } = region;
            floatingRegion = {
                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                ...rest,
            };
        }
        else {
            floatingRegion = {
                region,
                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
            };
        }
        if (!this._settings.floatingRegions)
            this._settings.floatingRegions = [];
        this._settings.floatingRegions.push(floatingRegion);
        return this;
    }
    floatingRegions(regionOrMaxOffset, ...regions) {
        let maxOffset;
        if (utils.types.isNumber(regionOrMaxOffset)) {
            maxOffset = regionOrMaxOffset;
        }
        else {
            this.floatingRegion(regionOrMaxOffset);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.floatingRegion(region);
            else
                this.floatingRegion(region, maxOffset, maxOffset, maxOffset, maxOffset);
        });
        return this;
    }
    floating(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (utils.types.has(region, 'region'))
            return this.floatingRegion(region);
        else
            return this.floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset);
    }
    floatings(regionOrMaxOffset, ...regions) {
        return this.floatingRegions(regionOrMaxOffset, ...regions);
    }
    accessibilityRegion(region, type) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        const accessibilityRegion = utils.types.has(region, 'region') ? region : { region, type };
        if (!this._settings.accessibilityRegions)
            this._settings.accessibilityRegions = [];
        this._settings.accessibilityRegions.push(accessibilityRegion);
        return this;
    }
    accessibilityRegions(regionOrType, ...regions) {
        let type;
        if (utils.types.isEnumValue(regionOrType, AccessibilityRegionType_1.AccessibilityRegionTypeEnum)) {
            type = regionOrType;
        }
        else {
            this.accessibilityRegion(regionOrType);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.accessibilityRegion(region);
            else
                this.accessibilityRegion(region, type);
        });
        return this;
    }
    matchLevel(matchLevel) {
        this._settings.matchLevel = matchLevel;
        return this;
    }
    layout() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Layout;
        return this;
    }
    exact() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Exact;
        return this;
    }
    strict() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Strict;
        return this;
    }
    ignoreColors() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.IgnoreColors;
        return this;
    }
    /** @deprecated */
    content() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Content;
        return this;
    }
    enablePatterns(enablePatterns = true) {
        this._settings.enablePatterns = enablePatterns;
        return this;
    }
    ignoreDisplacements(ignoreDisplacements = true) {
        this._settings.ignoreDisplacements = ignoreDisplacements;
        return this;
    }
    ignoreCaret(ignoreCaret = true) {
        this._settings.ignoreCaret = ignoreCaret;
        return this;
    }
    useDom(useDom = true) {
        this._settings.useDom = useDom;
        return this;
    }
    sendDom(sendDom = true) {
        this._settings.sendDom = sendDom;
        return this;
    }
    pageId(pageId) {
        this._settings.pageId = pageId;
        return this;
    }
    variationGroupId(variationGroupId) {
        this._settings.variationGroupId = variationGroupId;
        return this;
    }
    /** @internal */
    toObject() {
        return this._settings;
    }
    /** @internal */
    toString() {
        return utils.general.toString(this);
    }
}
exports.CheckSettingsBaseFluent = CheckSettingsBaseFluent;
class CheckSettingsImageFluent extends CheckSettingsBaseFluent {
    constructor(settings, target) {
        super(settings);
        this._target = target !== null && target !== void 0 ? target : settings === null || settings === void 0 ? void 0 : settings._target;
    }
    image(image) {
        var _a;
        (_a = this._target) !== null && _a !== void 0 ? _a : (this._target = {});
        this._target.image = image;
        return this;
    }
    buffer(imageBuffer) {
        return this.image(imageBuffer);
    }
    base64(imageBase64) {
        return this.image(imageBase64);
    }
    path(imagePath) {
        return this.image(imagePath);
    }
    url(imageUrl) {
        return this.image(imageUrl);
    }
    name(name) {
        this._target.name = name;
        return super.name(name);
    }
    withDom(dom) {
        this._settings.sendDom = true;
        this._target.dom = dom;
        return this;
    }
    withLocation(locationInViewport) {
        this._target.locationInViewport = locationInViewport;
        return this;
    }
    /** @internal */
    toJSON() {
        return {
            target: this._target,
            settings: utils.general.removeUndefinedProps({
                name: this._settings.name,
                region: this._settings.region,
                matchLevel: this._settings.matchLevel,
                useDom: this._settings.useDom,
                sendDom: this._settings.sendDom,
                enablePatterns: this._settings.enablePatterns,
                ignoreDisplacements: this._settings.ignoreDisplacements,
                ignoreCaret: this._settings.ignoreCaret,
                ignoreRegions: this._settings.ignoreRegions,
                layoutRegions: this._settings.layoutRegions,
                strictRegions: this._settings.strictRegions,
                contentRegions: this._settings.contentRegions,
                floatingRegions: this._settings.floatingRegions,
                accessibilityRegions: this._settings.accessibilityRegions,
                pageId: this._settings.pageId,
                userCommandId: this._settings.variationGroupId,
            }),
        };
    }
}
exports.CheckSettingsImageFluent = CheckSettingsImageFluent;
class CheckSettingsAutomationFluent extends CheckSettingsBaseFluent {
    _isElementReference(value) {
        var _a, _b;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return !!((_b = spec.isElement) === null || _b === void 0 ? void 0 : _b.call(spec, value)) || this._isSelectorReference(value);
    }
    _isSelectorReference(selector) {
        var _a, _b, _c;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return (!!((_b = spec.isSelector) === null || _b === void 0 ? void 0 : _b.call(spec, selector)) ||
            utils.types.isString(selector) ||
            (utils.types.isPlainObject(selector) &&
                utils.types.has(selector, 'selector') &&
                (utils.types.isString(selector.selector) || !!((_c = spec.isSelector) === null || _c === void 0 ? void 0 : _c.call(spec, selector.selector)))));
    }
    _isFrameReference(value) {
        return utils.types.isNumber(value) || utils.types.isString(value) || this._isElementReference(value);
    }
    constructor(settings, spec) {
        var _a;
        super(settings);
        this._spec = spec;
        (_a = this._settings) !== null && _a !== void 0 ? _a : (this._settings = {});
    }
    region(region) {
        if (this._isSelectorReference(region) &&
            this._isSelectorReference(this._settings.region) &&
            utils.types.has(this._settings.region, 'selector')) {
            let lastSelector = this._settings.region;
            while (lastSelector.shadow)
                lastSelector = lastSelector.shadow;
            lastSelector.shadow = region;
            return this;
        }
        return super.region(region);
    }
    shadow(selector) {
        selector = utils.types.has(selector, 'selector') ? selector : { selector };
        if (!this._settings.region) {
            this._settings.region = selector;
        }
        else if (this._isSelectorReference(this._settings.region)) {
            let lastSelector;
            if (utils.types.has(this._settings.region, 'selector')) {
                lastSelector = this._settings.region;
                while (lastSelector.shadow)
                    lastSelector = lastSelector.shadow;
            }
            else {
                lastSelector = { selector: this._settings.region };
            }
            lastSelector.shadow = selector;
        }
        return this;
    }
    frame(contextOrFrame, scrollRootElement) {
        const context = this._isFrameReference(contextOrFrame) || this._isSelectorReference(contextOrFrame)
            ? { frame: contextOrFrame, scrollRootElement }
            : contextOrFrame;
        if (!this._settings.frames)
            this._settings.frames = [];
        this._settings.frames.push(context);
        return this;
    }
    webview(webview) {
        this._settings.webview = webview !== null && webview !== void 0 ? webview : true;
        return this;
    }
    scrollRootElement(scrollRootElement) {
        if (this._settings.frames && this._settings.frames.length > 0) {
            const context = this._settings.frames[this._settings.frames.length - 1];
            context.scrollRootElement = scrollRootElement;
        }
        this._settings.scrollRootElement = scrollRootElement;
        return this;
    }
    fully(fully = true) {
        this._settings.fully = fully;
        return this;
    }
    /** @deprecated */
    stitchContent(stitchContent = true) {
        return this.fully(stitchContent);
    }
    disableBrowserFetching(disableBrowserFetching) {
        this._settings.disableBrowserFetching = disableBrowserFetching;
        return this;
    }
    layoutBreakpoints(breakpoints = true, settings) {
        this._settings.layoutBreakpoints = {
            breakpoints: utils.types.isArray(breakpoints)
                ? Array.from(new Set(breakpoints)).sort((a, b) => (a < b ? 1 : -1))
                : breakpoints,
            reload: settings === null || settings === void 0 ? void 0 : settings.reload,
        };
        return this;
    }
    hook(name, script) {
        this._settings.hooks = { ...this._settings.hooks, [name]: script };
        return this;
    }
    beforeRenderScreenshotHook(script) {
        return this.hook('beforeCaptureScreenshot', script);
    }
    /** @deprecated */
    webHook(script) {
        return this.beforeRenderScreenshotHook(script);
    }
    ufgOption(key, value) {
        this._settings.visualGridOptions = { ...this._settings.visualGridOptions, [key]: value };
        return this;
    }
    ufgOptions(options) {
        this._settings.visualGridOptions = options;
        return this;
    }
    /** @deprecated */
    visualGridOption(key, value) {
        return this.ufgOption(key, value);
    }
    /** @deprecated */
    visualGridOptions(options) {
        return this.ufgOptions(options);
    }
    useSystemScreenshot(useSystemScreenshot) {
        this._settings.useSystemScreenshot = useSystemScreenshot;
        return this;
    }
    timeout(timeout) {
        this._settings.timeout = timeout;
        return this;
    }
    waitBeforeCapture(waitBeforeCapture) {
        this._settings.waitBeforeCapture = waitBeforeCapture;
        return this;
    }
    lazyLoad(options) {
        this._settings.lazyLoad = options !== null && options !== void 0 ? options : true;
        return this;
    }
    densityMetrics(options) {
        this._settings.densityMetrics = options;
        return this;
    }
    /** @internal */
    toJSON() {
        var _a;
        return {
            target: undefined,
            settings: utils.general.removeUndefinedProps({
                name: this._settings.name,
                region: this._settings.region,
                frames: this._settings.frames,
                webview: this._settings.webview,
                scrollRootElement: this._settings.scrollRootElement,
                fully: this._settings.fully,
                matchLevel: this._settings.matchLevel,
                useDom: this._settings.useDom,
                sendDom: this._settings.sendDom,
                enablePatterns: this._settings.enablePatterns,
                ignoreDisplacements: this._settings.ignoreDisplacements,
                ignoreCaret: this._settings.ignoreCaret,
                ignoreRegions: this._settings.ignoreRegions,
                layoutRegions: this._settings.layoutRegions,
                strictRegions: this._settings.strictRegions,
                contentRegions: this._settings.contentRegions,
                floatingRegions: this._settings.floatingRegions &&
                    this._settings.floatingRegions.map(floatingRegion => {
                        if (utils.types.has(floatingRegion, 'region')) {
                            const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...rest } = floatingRegion;
                            return {
                                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                                ...rest,
                            };
                        }
                        return floatingRegion;
                    }),
                accessibilityRegions: this._settings.accessibilityRegions,
                disableBrowserFetching: this._settings.disableBrowserFetching,
                layoutBreakpoints: utils.types.isDefined(this._settings.layoutBreakpoints)
                    ? utils.types.has(this._settings.layoutBreakpoints, 'breakpoints')
                        ? this._settings.layoutBreakpoints
                        : { breakpoints: (_a = this._settings.layoutBreakpoints) !== null && _a !== void 0 ? _a : false }
                    : undefined,
                ufgOptions: this._settings.visualGridOptions,
                screenshotMode: this._settings.useSystemScreenshot ? 'default' : undefined,
                hooks: this._settings.hooks,
                pageId: this._settings.pageId,
                lazyLoad: this._settings.lazyLoad,
                waitBeforeCapture: this._settings.waitBeforeCapture,
                retryTimeout: this._settings.timeout,
                userCommandId: this._settings.variationGroupId,
                densityMetrics: this._settings.densityMetrics,
            }),
        };
    }
}
exports.CheckSettingsAutomationFluent = CheckSettingsAutomationFluent;
exports.TargetImage = {
    image(image) {
        return new CheckSettingsImageFluent().image(image);
    },
    buffer(imageBuffer) {
        return new CheckSettingsImageFluent().image(imageBuffer);
    },
    base64(imageBase64) {
        return new CheckSettingsImageFluent().image(imageBase64);
    },
    path(imagePath) {
        return new CheckSettingsImageFluent().image(imagePath);
    },
    url(imageUrl) {
        return new CheckSettingsImageFluent().image(imageUrl);
    },
};
exports.TargetAutomation = {
    spec: null,
    window() {
        return new CheckSettingsAutomationFluent({}, this.spec);
    },
    region(region) {
        return new CheckSettingsAutomationFluent({}, this.spec).region(region);
    },
    frame(contextOrFrame, scrollRootElement) {
        return new CheckSettingsAutomationFluent({}, this.spec).frame(contextOrFrame, scrollRootElement);
    },
    shadow(selector) {
        return new CheckSettingsAutomationFluent({}, this.spec).shadow(selector);
    },
    webview(webview) {
        return new CheckSettingsAutomationFluent({}, this.spec).webview(webview);
    },
};
exports.Target = { ...exports.TargetImage, ...exports.TargetAutomation };
