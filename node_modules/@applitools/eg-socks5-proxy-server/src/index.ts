import {
  RFC_1928_ATYP,
  RFC_1928_COMMANDS,
  RFC_1928_METHODS,
  RFC_1928_REPLIES,
  RFC_1928_VERSION,
  RFC_1929_REPLIES,
  RFC_1929_VERSION,
} from './constants'

import * as EVENTS from './events'
import {endConnection} from './end-socket-connection'
import {handshake} from './handshake'
import {authenticate} from './authenticate'
import {parseConnectBuffer} from './parse-connect-buffer'
import {executeRequest} from './execute-request'
import {executeRequestThroughRemoteProxy} from './execute-request-through-remote-proxy'

import binary from 'binary'
import domain from 'domain'
import net, {Socket} from 'net'
import isLocalhostIp from 'is-localhost-ip'

import {ISocksServer, ProxyServers, SetProxyServerOptions, Socks5ProxyOptions} from '../types'
import {HandshakeCompletedHandler} from '../types/handshake'
import {IProxyServer} from '../types/execute-request-through-remote-proxy'
import {ConnectBufferObject} from '../types/parse-connect-buffer'
import {AddressInfo} from '../types/utils'

const _alwaysTrue = (data: {
  socket: net.Socket
  destinationInfo: AddressInfo
  originInfo: AddressInfo
}) => true

/**
 * The following RFCs may be useful as background:
 *
 * https://www.ietf.org/rfc/rfc1928.txt - NO_AUTH SOCKS5
 * https://www.ietf.org/rfc/rfc1929.txt - USERNAME/PASSWORD SOCKS5
 *
 **/
export class SocksServer implements ISocksServer {
  private _server: net.Server
  private options: Socks5ProxyOptions
  private activeSessions: Socket[] = []
  private destinationSockets: Socket[] = []
  private syncDestinationSocketInterval

  constructor(options: Socks5ProxyOptions) {
    const self = this
    this.options = options || {}

    this.syncDestinationSocketInterval = setInterval(() => {
      this.destinationSockets = this.destinationSockets.filter((dest: Socket) => !dest.destroyed)
    }, 5000)

    this._server = net.createServer((socket) => {
      let clientHandshakeBuffer: Buffer
      socket.on('error', (err) => {
        self.server.emit(EVENTS.ORIGIN_SOCKET_ERROR, {err, socket})
      })
      socket.setKeepAlive(true)

      function _authenticate(buffer: Buffer) {
        authenticate({
          socket,
          buffer,
          options: self.options,
          connect,
          end,
          onAuthenticated: (args) =>
            self.server.emit(EVENTS.AUTHENTICATION, args.username.toString()),
          onFailed: (args, err) =>
            self.server.emit(EVENTS.AUTHENTICATION_ERROR, args.username.toString(), err),
        })
      }
      /**
       * +----+-----+-------+------+----------+----------+
       * |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
       * +----+-----+-------+------+----------+----------+
       * | 1  |  1  | X'00' |  1   | Variable |    2     |
       * +----+-----+-------+------+----------+----------+
       *
       * @param {Buffer} buffer - a buffer
       * @returns {undefined}
       **/
      function connect(buffer: Buffer) {
        const onParseCompleted = (args: ConnectBufferObject) => {
          if (args.cmd !== RFC_1928_COMMANDS.CONNECT) {
            // bind and udp associate commands
            return end(RFC_1928_REPLIES.SUCCEEDED, args)
          }

          const connectionFilterDomain = domain.create()
          let connectionFilter = self.options.connectionFilter

          // if no connection filter is provided, stub one
          if (!connectionFilter || typeof connectionFilter !== 'function') {
            connectionFilter = (destination, origin, callback) => setImmediate(callback)
          }

          // capture connection filter errors
          connectionFilterDomain.on('error', (err) => {
            // emit failed destination connection event
            self.server.emit(
              EVENTS.CONNECTION_FILTER,
              // destination
              {
                address: args.dst.addr,
                port: args.dst.port,
              },
              // origin
              {
                address: socket.remoteAddress,
                port: socket.remotePort,
              },
              err,
            )

            // respond with failure
            return end(RFC_1928_REPLIES.CONNECTION_NOT_ALLOWED, args)
            //return end(RFC_1929_REPLIES.CONNECTION_NOT_ALLOWED, args)
          })

          // perform connection
          return connectionFilter(
            // destination
            {
              address: args.dst.addr,
              port: args.dst.port,
            },
            // origin
            {
              address: socket.remoteAddress,
              port: socket.remotePort,
            },
            connectionFilterDomain.intercept(async () => {
              const destinationInfo: AddressInfo = {
                address: args.dst.addr,
                port: args.dst.port,
              }

              const originInfo: AddressInfo = {
                address: socket.remoteAddress,
                port: socket.remotePort,
              }

              if (
                self.options.shouldBlockPrivateAddresses &&
                (await isLocalhostIp(destinationInfo.address!))
              ) {
                self.server.emit(EVENTS.PRIVATE_ADDRESS_WAS_BLOCKED, {
                  destinationInfo,
                  originInfo,
                })
                return end(RFC_1928_REPLIES.CONNECTION_NOT_ALLOWED, args)
              }

              let createExecuterAndRegisterToEvents: any = null

              let proxyServer: Partial<IProxyServer> | undefined = undefined

              if (self.options.proxyServers?.getAvailableProxy()) {
                proxyServer = {
                  ...self.options.proxyServers.getAvailableProxy(),
                  shouldUseProxy: self.options.proxyServers.shouldUseProxy || _alwaysTrue,
                }
              }

              const shouldUseProxy: boolean =
                proxyServer?.shouldUseProxy!({
                  socket,
                  destinationInfo,
                  originInfo,
                }) || false

              const proxyInfo =
                proxyServer && shouldUseProxy
                  ? {
                      address: proxyServer.address,
                      port: proxyServer.port,
                    }
                  : undefined

              const basicEventData = {
                originInfo,
                destinationInfo,
                proxyInfo,
              }

              self.server.emit(EVENTS.ACCEPT_NEW_REQUEST, basicEventData)

              if (proxyServer && shouldUseProxy) {
                const retries = {handshake: 0, rpcReply: 0}

                proxyServer.onHandshakeCompleted = () => {
                  self.server.emit(EVENTS.REMOTE_PROXY_HANDSHAKE_COMPLETED, basicEventData)
                }

                proxyServer.onHandshakeTimeout = () => {
                  self.server.emit(EVENTS.REMOTE_PROXY_HANDSHAKE_TIMEOUT, {
                    ...basicEventData,
                    timeout: proxyServer!.handshakeTimeout,
                  })

                  retries.handshake++
                  if (retries.handshake <= 3) createExecuterAndRegisterToEvents()
                  else end(RFC_1928_REPLIES.NETWORK_UNREACHABLE, args)
                }

                proxyServer.onRpc1928ReplyTimeout = () => {
                  self.server.emit(EVENTS.REMOTE_PROXY_RFC_1928_REPLY_TIMEOUT, {
                    ...basicEventData,
                    timeout: proxyServer!.rpcReplyTimeout,
                  })

                  retries.rpcReply++
                  if (retries.rpcReply <= 3) createExecuterAndRegisterToEvents()
                  else end(RFC_1928_REPLIES.NETWORK_UNREACHABLE, args)
                }

                proxyServer.onRpc1928Reply = (reply: Buffer) => {
                  self.server.emit(EVENTS.REMOTE_PROXY_RFC_1928_REPLY, {
                    ...basicEventData,
                    reply,
                  })
                }
              }

              createExecuterAndRegisterToEvents = () => {
                const connectionTimeout = 120000
                let connectionTimeoutId: NodeJS.Timeout | null = setTimeout(
                  () =>
                    self.server.emit(EVENTS.REMOTE_CONNECTION_TIMEOUT_ERROR, {
                      ...basicEventData,
                      timeout: connectionTimeout,
                    }),
                  connectionTimeout,
                )

                let destination: net.Socket

                const clearConnectionTimeout = () => {
                  connectionTimeoutId && clearTimeout(connectionTimeoutId)
                  connectionTimeoutId = null
                }

                const onConnect = (destinationSocket: Socket) => {
                  connectionFilterDomain.exit()
                  clearConnectionTimeout()

                  // close destination socket when after original socket was closed
                  socket.on('close', () => {
                    destinationSocket.destroy()
                    self.destinationSockets.splice(
                      self.destinationSockets.indexOf(destinationSocket),
                      1,
                    )
                  })

                  const event = shouldUseProxy
                    ? EVENTS.CONNECTED_TO_REMOTE_PROXY
                    : EVENTS.CONNECTED_TO_REMOTE_ADDRESS
                  self.server.emit(event, {destinationInfo, originInfo, proxyInfo})
                }

                const onError = (err: Error) => {
                  // exit the connection filter domain
                  connectionFilterDomain.exit()

                  self.server.emit(EVENTS.REMOTE_SOCKET_ERROR, {
                    err,
                    destination,
                    args,
                    originInfo,
                    destinationInfo,
                    proxyInfo,
                  })
                }

                if (!shouldUseProxy) {
                  destination = executeRequest({
                    originalSocket: socket,
                    addressType: args.atyp,
                    address: args.dst.addr,
                    port: args.dst.port,
                    requestBuffer: args.requestBuffer,
                    end,
                    onConnect,
                    onError,
                  })
                } else {
                  destination = executeRequestThroughRemoteProxy({
                    originalSocket: socket,
                    clientHandshakeBuffer,
                    proxyServer: proxyServer as IProxyServer,
                    addressType: args.atyp,
                    address: args.dst.addr,
                    port: args.dst.port,
                    requestBuffer: args.requestBuffer,
                    end,
                    onConnect,
                    onError,
                  })
                }

                self.destinationSockets.push(destination)
              }

              createExecuterAndRegisterToEvents()
            }),
          )
        }

        parseConnectBuffer({
          buffer,
          onReqesutBufferParsed: () => self.activeSessions.push(socket),
          onParseCompleted,
          end,
        })
      }

      /**
       * +----+-----+-------+------+----------+----------+
       * |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
       * +----+-----+-------+------+----------+----------+
       * | 1  |  1  | X'00' |  1   | Variable |    2     |
       * +----+-----+-------+------+----------+----------+
       *
       * @param {Buffer} response - a buffer representing the response
       * @param {object} args - arguments to supply to the proxy end event
       * @returns {undefined}
       **/
      function end(response: number, args: any) {
        endConnection({socket, response, args})
        // indicate end of connection
        self.server.emit(EVENTS.PROXY_END, response, args)
      }

      /**
       * +----+----------+----------+
       * |VER | NMETHODS | METHODS  |
       * +----+----------+----------+
       * | 1  |    1     | 1 to 255 |
       * +----+----------+----------+
       *
       * @param {Buffer} buffer - a buffer
       * @returns {undefined}
       **/

      function _handshake(buffer: Buffer) {
        clientHandshakeBuffer = buffer

        const onHandshakeCompleted: HandshakeCompletedHandler = ({
          clientHandshakeBuffer,
          responseBuffer,
        }) => {
          self.server.emit(EVENTS.HANDSHAKE, {socket, clientHandshakeBuffer, responseBuffer})
        }

        handshake({
          socket,
          buffer,
          options: self.options,
          connect,
          authenticate: _authenticate,
          onHandshakeCompleted,
          end,
        })
      }

      socket.once('data', _handshake)

      // capture socket closure
      socket.once('end', () => {
        // remove the session from currently the active sessions list
        self.activeSessions.splice(self.activeSessions.indexOf(socket), 1)
      })
    })
  }

  public on = (event: string, listener: (...args: any[]) => void) => this.server.on(event, listener)
  public listen = (...args: any[]) => this.server.listen(...args)
  public listenAsync = (port: number, host = '127.0.0.1') => {
    const promise = new Promise<void>((resolve, reject) => {
      try {
        this.server.listen(port, host, resolve)
      } catch (e) {
        reject(e)
      }
    })

    return promise
  }

  public close = (...args: any[]) => {
    this.syncDestinationSocketInterval && clearInterval(this.syncDestinationSocketInterval)
    return this.server.close(...args)
  }
  public getConnections = (cb: (error: Error | null, count: number) => void) =>
    this.server.getConnections(cb)

  public setProxyServer = ({address, port, shouldUseProxy}: SetProxyServerOptions) => {
    const getAvailableProxy = () => ({address, port})
    this.options.proxyServers = {shouldUseProxy, getAvailableProxy}
  }

  public setProxyServers = (proxyServers: ProxyServers) => {
    this.options.proxyServers = proxyServers
  }

  public getProxyServers = () => this.options.proxyServers

  public set shouldBlockPrivateAddresses(value: boolean) {
    this.options.shouldBlockPrivateAddresses = value
  }

  public get shouldBlockPrivateAddresses() {
    return !!this.options.shouldBlockPrivateAddresses
  }

  public get server() {
    return this._server
  }
}

export function createSocks5ProxyServer(options: Socks5ProxyOptions = {}): SocksServer {
  const socksServer = new SocksServer(options)
  return socksServer
}

export * as EVENTS from './events'
