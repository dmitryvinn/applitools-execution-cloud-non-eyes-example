import binary from 'binary'
import {Buffer} from 'buffer'
import {HandshakePatameters, IDictionary} from '../types/handshake'

import {RFC_1928_METHODS, RFC_1928_REPLIES, RFC_1928_VERSION} from './constants'

/**
 * +----+----------+----------+
 * |VER | NMETHODS | METHODS  |
 * +----+----------+----------+
 * | 1  |    1     | 1 to 255 |
 * +----+----------+----------+
 *
 * @param {Socket} socket - a socket
 * @param {Buffer} buffer - a buffer
 * @param {any} options
 * @param {Function} connet
 * @param {Function} authenticate
 * @param {Function} end
 * @param {Function} onHandshakeCompleted
 *
 * @returns {undefined}
 **/

export function handshake({
  socket,
  buffer,
  options,
  connect,
  authenticate,
  end,
  onHandshakeCompleted,
}: HandshakePatameters) {
  const clientHandshakeBuffer = buffer
  binary
    .stream(buffer)
    .word8('version')
    .word8('nmethods')
    .buffer('methods', 'nmethods')
    .tap((args: {version: number; methods: any}) => {
      // verify version is appropriate
      if (args.version !== RFC_1928_VERSION) {
        return end(RFC_1928_REPLIES.GENERAL_FAILURE, args)
      }

      // convert methods buffer to an array
      const acceptedMethods: IDictionary<boolean> = [].slice
        .call(args.methods)
        .reduce((methods: IDictionary<boolean>, method: string) => {
          methods[method] = true
          return methods
        }, {})

      const basicAuth = typeof options.authenticate === 'function'
      const noAuth = !basicAuth && typeof acceptedMethods[0] !== 'undefined' && acceptedMethods[0]

      const responseBuffer = Buffer.allocUnsafe(2)

      // form response Buffer
      responseBuffer[0] = RFC_1928_VERSION
      responseBuffer[1] = RFC_1928_METHODS.NO_AUTHENTICATION_REQUIRED

      let next = connect

      // check for basic auth configuration
      if (basicAuth) {
        responseBuffer[1] = RFC_1928_METHODS.BASIC_AUTHENTICATION
        next = authenticate

        // if NO AUTHENTICATION REQUIRED and
      } else if (!basicAuth && noAuth) {
        responseBuffer[1] = RFC_1928_METHODS.NO_AUTHENTICATION_REQUIRED
        next = connect

        // basic auth callback not provided and no auth is not supported
      } else {
        return end(RFC_1928_METHODS.NO_ACCEPTABLE_METHODS, args)
      }

      // respond then listen for cmd and dst info
      socket.write(responseBuffer, () => {
        // emit handshake event
        socket.once('data', next)
        onHandshakeCompleted && onHandshakeCompleted({clientHandshakeBuffer, responseBuffer})
        // now listen for more details
      })
    })
}
