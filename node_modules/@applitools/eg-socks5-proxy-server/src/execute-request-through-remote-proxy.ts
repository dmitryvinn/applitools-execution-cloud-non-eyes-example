import net from 'net'

import {RFC_1928_REPLIES} from './constants'
import {convertSocketErrorToRpcReply} from './utils/convert-socket-error-to-rpc-reply'

import {ExecuteReqeustError} from '../types/execute-request'
import {
  ExecuteRequestThroughRemoteProxyParameters,
  WriteAndWaitParameters,
} from '../types/execute-request-through-remote-proxy'

export function executeRequestThroughRemoteProxy({
  originalSocket,
  proxyServer,
  addressType,
  address,
  port,
  requestBuffer,
  clientHandshakeBuffer,
  end,
  onError,
  onConnect,
}: ExecuteRequestThroughRemoteProxyParameters) {
  let stopTimeout: () => void

  const destination = net.createConnection(proxyServer.port, proxyServer.address, () => {
    // prepare a success response
    const responseBuffer = Buffer.alloc(requestBuffer.length)
    requestBuffer.copy(responseBuffer)
    responseBuffer[1] = RFC_1928_REPLIES.SUCCEEDED

    const onHandshakeCompleted = (_data: any) => {
      ;[stopTimeout] = _writeAndWaitForResponse({
        socket: destination,
        data: requestBuffer,
        timeout: proxyServer.rpcReplyTimeout || 5000,
        onTimeout: () => {
          destination.destroy()
          proxyServer.onRpc1928ReplyTimeout()
        },
        onComplete: (data) => {
          originalSocket.write(data, () => {
            destination.pipe(originalSocket)
            originalSocket.pipe(destination)
          })

          proxyServer.onRpc1928Reply(data)
        },
      })

      proxyServer.onHandshakeCompleted()
    }

    ;[stopTimeout] = _writeAndWaitForResponse({
      socket: destination,
      data: clientHandshakeBuffer,
      timeout: proxyServer.handshakeTimeout || 5000,
      onTimeout: () => {
        destination.destroy()
        proxyServer.onHandshakeTimeout()
      },
      onComplete: onHandshakeCompleted,
    })
  })

  destination.setKeepAlive(true)

  // capture successful connection
  destination.on('connect', () => {
    onConnect(destination)
  })

  // capture connection errors and response appropriately
  destination.on('error', (err: ExecuteReqeustError) => {
    stopTimeout && stopTimeout()

    // notify of connection error
    err.addr = address
    err.atyp = addressType
    err.port = port

    onError(err)

    const rpcReply = convertSocketErrorToRpcReply(err)
    return end(rpcReply, {requestBuffer})
  })

  return destination
}

function _writeAndWaitForResponse({
  socket,
  data,
  timeout,
  onTimeout,
  onComplete,
}: WriteAndWaitParameters) {
  let wasTimeoutCalled = false

  const timeoutId = setTimeout(() => {
    wasTimeoutCalled = true
    onTimeout()
  }, timeout)

  const stopTimeoutFn = () => clearTimeout(timeoutId)
  socket.write(data, () => {
    socket.once('data', (response) => {
      if (wasTimeoutCalled) return

      stopTimeoutFn()
      onComplete(response)
    })
  })

  return [stopTimeoutFn]
}
