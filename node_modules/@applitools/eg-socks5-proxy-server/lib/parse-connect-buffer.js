"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConnectBuffer = void 0;
const binary_1 = __importDefault(require("binary"));
const constants_1 = require("./constants");
const LENGTH_RFC_1928_ATYP = 4;
function parseConnectBuffer({ buffer, onReqesutBufferParsed, onParseCompleted, end, }) {
    const binaryStream = binary_1.default.stream(buffer);
    binaryStream
        .word8('ver')
        .word8('cmd')
        .word8('rsv')
        .word8('atyp')
        .tap((args) => {
        // capture the raw buffer
        //debugger
        args.requestBuffer = buffer;
        // verify version is appropriate
        if (args.ver !== constants_1.RFC_1928_VERSION) {
            return end(constants_1.RFC_1928_REPLIES.GENERAL_FAILURE, args);
        }
        // append socket to active sessions
        onReqesutBufferParsed();
        // create dst
        args.dst = {};
        // ipv4
        if (args.atyp === constants_1.RFC_1928_ATYP.IPV4) {
            binaryStream.buffer('addr.buf', LENGTH_RFC_1928_ATYP).tap((args) => {
                args.dst.addr = [].slice.call(args.addr.buf).join('.');
            });
            // domain name
        }
        else if (args.atyp === constants_1.RFC_1928_ATYP.DOMAINNAME) {
            binaryStream
                .word8('addr.size')
                .buffer('addr.buf', 'addr.size')
                .tap((args) => {
                args.dst.addr = args.addr.buf.toString();
            });
            // ipv6
        }
        else if (args.atyp === constants_1.RFC_1928_ATYP.IPV6) {
            binaryStream
                .word32be('addr.a')
                .word32be('addr.b')
                .word32be('addr.c')
                .word32be('addr.d')
                .tap((args) => {
                args.dst.addr = [];
                ['a', 'b', 'c', 'd'].forEach((x) => {
                    x = args.addr[x];
                    // convert DWORD to two WORD values and append
                    /* eslint no-magic-numbers : 0 */
                    args.dst.addr.push((x >>> 16).toString(16));
                    args.dst.addr.push((x & 0xffff).toString(16));
                });
                // format ipv6 address as string
                args.dst.addr = args.dst.addr.join(':');
            });
            // unsupported address type
        }
        else {
            return end(constants_1.RFC_1928_REPLIES.ADDRESS_TYPE_NOT_SUPPORTED, args);
        }
    })
        .word16bu('dst.port')
        .tap((args) => {
        onParseCompleted(args);
    });
}
exports.parseConnectBuffer = parseConnectBuffer;
//# sourceMappingURL=parse-connect-buffer.js.map