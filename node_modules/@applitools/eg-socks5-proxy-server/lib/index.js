"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVENTS = exports.createSocks5ProxyServer = exports.SocksServer = void 0;
const constants_1 = require("./constants");
const EVENTS = __importStar(require("./events"));
const end_socket_connection_1 = require("./end-socket-connection");
const handshake_1 = require("./handshake");
const authenticate_1 = require("./authenticate");
const parse_connect_buffer_1 = require("./parse-connect-buffer");
const execute_request_1 = require("./execute-request");
const execute_request_through_remote_proxy_1 = require("./execute-request-through-remote-proxy");
const domain_1 = __importDefault(require("domain"));
const net_1 = __importDefault(require("net"));
const is_localhost_ip_1 = __importDefault(require("is-localhost-ip"));
const _alwaysTrue = (data) => true;
/**
 * The following RFCs may be useful as background:
 *
 * https://www.ietf.org/rfc/rfc1928.txt - NO_AUTH SOCKS5
 * https://www.ietf.org/rfc/rfc1929.txt - USERNAME/PASSWORD SOCKS5
 *
 **/
class SocksServer {
    constructor(options) {
        this.activeSessions = [];
        this.destinationSockets = [];
        this.on = (event, listener) => this.server.on(event, listener);
        this.listen = (...args) => this.server.listen(...args);
        this.listenAsync = (port, host = '127.0.0.1') => {
            const promise = new Promise((resolve, reject) => {
                try {
                    this.server.listen(port, host, resolve);
                }
                catch (e) {
                    reject(e);
                }
            });
            return promise;
        };
        this.close = (...args) => {
            this.syncDestinationSocketInterval && clearInterval(this.syncDestinationSocketInterval);
            return this.server.close(...args);
        };
        this.getConnections = (cb) => this.server.getConnections(cb);
        this.setProxyServer = ({ address, port, shouldUseProxy }) => {
            const getAvailableProxy = () => ({ address, port });
            this.options.proxyServers = { shouldUseProxy, getAvailableProxy };
        };
        this.setProxyServers = (proxyServers) => {
            this.options.proxyServers = proxyServers;
        };
        this.getProxyServers = () => this.options.proxyServers;
        const self = this;
        this.options = options || {};
        this.syncDestinationSocketInterval = setInterval(() => {
            this.destinationSockets = this.destinationSockets.filter((dest) => !dest.destroyed);
        }, 5000);
        this._server = net_1.default.createServer((socket) => {
            let clientHandshakeBuffer;
            socket.on('error', (err) => {
                self.server.emit(EVENTS.ORIGIN_SOCKET_ERROR, { err, socket });
            });
            socket.setKeepAlive(true);
            function _authenticate(buffer) {
                (0, authenticate_1.authenticate)({
                    socket,
                    buffer,
                    options: self.options,
                    connect,
                    end,
                    onAuthenticated: (args) => self.server.emit(EVENTS.AUTHENTICATION, args.username.toString()),
                    onFailed: (args, err) => self.server.emit(EVENTS.AUTHENTICATION_ERROR, args.username.toString(), err),
                });
            }
            /**
             * +----+-----+-------+------+----------+----------+
             * |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
             * +----+-----+-------+------+----------+----------+
             * | 1  |  1  | X'00' |  1   | Variable |    2     |
             * +----+-----+-------+------+----------+----------+
             *
             * @param {Buffer} buffer - a buffer
             * @returns {undefined}
             **/
            function connect(buffer) {
                const onParseCompleted = (args) => {
                    if (args.cmd !== constants_1.RFC_1928_COMMANDS.CONNECT) {
                        // bind and udp associate commands
                        return end(constants_1.RFC_1928_REPLIES.SUCCEEDED, args);
                    }
                    const connectionFilterDomain = domain_1.default.create();
                    let connectionFilter = self.options.connectionFilter;
                    // if no connection filter is provided, stub one
                    if (!connectionFilter || typeof connectionFilter !== 'function') {
                        connectionFilter = (destination, origin, callback) => setImmediate(callback);
                    }
                    // capture connection filter errors
                    connectionFilterDomain.on('error', (err) => {
                        // emit failed destination connection event
                        self.server.emit(EVENTS.CONNECTION_FILTER, 
                        // destination
                        {
                            address: args.dst.addr,
                            port: args.dst.port,
                        }, 
                        // origin
                        {
                            address: socket.remoteAddress,
                            port: socket.remotePort,
                        }, err);
                        // respond with failure
                        return end(constants_1.RFC_1928_REPLIES.CONNECTION_NOT_ALLOWED, args);
                        //return end(RFC_1929_REPLIES.CONNECTION_NOT_ALLOWED, args)
                    });
                    // perform connection
                    return connectionFilter(
                    // destination
                    {
                        address: args.dst.addr,
                        port: args.dst.port,
                    }, 
                    // origin
                    {
                        address: socket.remoteAddress,
                        port: socket.remotePort,
                    }, connectionFilterDomain.intercept(async () => {
                        var _a;
                        const destinationInfo = {
                            address: args.dst.addr,
                            port: args.dst.port,
                        };
                        const originInfo = {
                            address: socket.remoteAddress,
                            port: socket.remotePort,
                        };
                        if (self.options.shouldBlockPrivateAddresses &&
                            (await (0, is_localhost_ip_1.default)(destinationInfo.address))) {
                            self.server.emit(EVENTS.PRIVATE_ADDRESS_WAS_BLOCKED, {
                                destinationInfo,
                                originInfo,
                            });
                            return end(constants_1.RFC_1928_REPLIES.CONNECTION_NOT_ALLOWED, args);
                        }
                        let createExecuterAndRegisterToEvents = null;
                        let proxyServer = undefined;
                        if ((_a = self.options.proxyServers) === null || _a === void 0 ? void 0 : _a.getAvailableProxy()) {
                            proxyServer = {
                                ...self.options.proxyServers.getAvailableProxy(),
                                shouldUseProxy: self.options.proxyServers.shouldUseProxy || _alwaysTrue,
                            };
                        }
                        const shouldUseProxy = (proxyServer === null || proxyServer === void 0 ? void 0 : proxyServer.shouldUseProxy({
                            socket,
                            destinationInfo,
                            originInfo,
                        })) || false;
                        const proxyInfo = proxyServer && shouldUseProxy
                            ? {
                                address: proxyServer.address,
                                port: proxyServer.port,
                            }
                            : undefined;
                        const basicEventData = {
                            originInfo,
                            destinationInfo,
                            proxyInfo,
                        };
                        self.server.emit(EVENTS.ACCEPT_NEW_REQUEST, basicEventData);
                        if (proxyServer && shouldUseProxy) {
                            const retries = { handshake: 0, rpcReply: 0 };
                            proxyServer.onHandshakeCompleted = () => {
                                self.server.emit(EVENTS.REMOTE_PROXY_HANDSHAKE_COMPLETED, basicEventData);
                            };
                            proxyServer.onHandshakeTimeout = () => {
                                self.server.emit(EVENTS.REMOTE_PROXY_HANDSHAKE_TIMEOUT, {
                                    ...basicEventData,
                                    timeout: proxyServer.handshakeTimeout,
                                });
                                retries.handshake++;
                                if (retries.handshake <= 3)
                                    createExecuterAndRegisterToEvents();
                                else
                                    end(constants_1.RFC_1928_REPLIES.NETWORK_UNREACHABLE, args);
                            };
                            proxyServer.onRpc1928ReplyTimeout = () => {
                                self.server.emit(EVENTS.REMOTE_PROXY_RFC_1928_REPLY_TIMEOUT, {
                                    ...basicEventData,
                                    timeout: proxyServer.rpcReplyTimeout,
                                });
                                retries.rpcReply++;
                                if (retries.rpcReply <= 3)
                                    createExecuterAndRegisterToEvents();
                                else
                                    end(constants_1.RFC_1928_REPLIES.NETWORK_UNREACHABLE, args);
                            };
                            proxyServer.onRpc1928Reply = (reply) => {
                                self.server.emit(EVENTS.REMOTE_PROXY_RFC_1928_REPLY, {
                                    ...basicEventData,
                                    reply,
                                });
                            };
                        }
                        createExecuterAndRegisterToEvents = () => {
                            const connectionTimeout = 120000;
                            let connectionTimeoutId = setTimeout(() => self.server.emit(EVENTS.REMOTE_CONNECTION_TIMEOUT_ERROR, {
                                ...basicEventData,
                                timeout: connectionTimeout,
                            }), connectionTimeout);
                            let destination;
                            const clearConnectionTimeout = () => {
                                connectionTimeoutId && clearTimeout(connectionTimeoutId);
                                connectionTimeoutId = null;
                            };
                            const onConnect = (destinationSocket) => {
                                connectionFilterDomain.exit();
                                clearConnectionTimeout();
                                // close destination socket when after original socket was closed
                                socket.on('close', () => {
                                    destinationSocket.destroy();
                                    self.destinationSockets.splice(self.destinationSockets.indexOf(destinationSocket), 1);
                                });
                                const event = shouldUseProxy
                                    ? EVENTS.CONNECTED_TO_REMOTE_PROXY
                                    : EVENTS.CONNECTED_TO_REMOTE_ADDRESS;
                                self.server.emit(event, { destinationInfo, originInfo, proxyInfo });
                            };
                            const onError = (err) => {
                                // exit the connection filter domain
                                connectionFilterDomain.exit();
                                self.server.emit(EVENTS.REMOTE_SOCKET_ERROR, {
                                    err,
                                    destination,
                                    args,
                                    originInfo,
                                    destinationInfo,
                                    proxyInfo,
                                });
                            };
                            if (!shouldUseProxy) {
                                destination = (0, execute_request_1.executeRequest)({
                                    originalSocket: socket,
                                    addressType: args.atyp,
                                    address: args.dst.addr,
                                    port: args.dst.port,
                                    requestBuffer: args.requestBuffer,
                                    end,
                                    onConnect,
                                    onError,
                                });
                            }
                            else {
                                destination = (0, execute_request_through_remote_proxy_1.executeRequestThroughRemoteProxy)({
                                    originalSocket: socket,
                                    clientHandshakeBuffer,
                                    proxyServer: proxyServer,
                                    addressType: args.atyp,
                                    address: args.dst.addr,
                                    port: args.dst.port,
                                    requestBuffer: args.requestBuffer,
                                    end,
                                    onConnect,
                                    onError,
                                });
                            }
                            self.destinationSockets.push(destination);
                        };
                        createExecuterAndRegisterToEvents();
                    }));
                };
                (0, parse_connect_buffer_1.parseConnectBuffer)({
                    buffer,
                    onReqesutBufferParsed: () => self.activeSessions.push(socket),
                    onParseCompleted,
                    end,
                });
            }
            /**
             * +----+-----+-------+------+----------+----------+
             * |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
             * +----+-----+-------+------+----------+----------+
             * | 1  |  1  | X'00' |  1   | Variable |    2     |
             * +----+-----+-------+------+----------+----------+
             *
             * @param {Buffer} response - a buffer representing the response
             * @param {object} args - arguments to supply to the proxy end event
             * @returns {undefined}
             **/
            function end(response, args) {
                (0, end_socket_connection_1.endConnection)({ socket, response, args });
                // indicate end of connection
                self.server.emit(EVENTS.PROXY_END, response, args);
            }
            /**
             * +----+----------+----------+
             * |VER | NMETHODS | METHODS  |
             * +----+----------+----------+
             * | 1  |    1     | 1 to 255 |
             * +----+----------+----------+
             *
             * @param {Buffer} buffer - a buffer
             * @returns {undefined}
             **/
            function _handshake(buffer) {
                clientHandshakeBuffer = buffer;
                const onHandshakeCompleted = ({ clientHandshakeBuffer, responseBuffer, }) => {
                    self.server.emit(EVENTS.HANDSHAKE, { socket, clientHandshakeBuffer, responseBuffer });
                };
                (0, handshake_1.handshake)({
                    socket,
                    buffer,
                    options: self.options,
                    connect,
                    authenticate: _authenticate,
                    onHandshakeCompleted,
                    end,
                });
            }
            socket.once('data', _handshake);
            // capture socket closure
            socket.once('end', () => {
                // remove the session from currently the active sessions list
                self.activeSessions.splice(self.activeSessions.indexOf(socket), 1);
            });
        });
    }
    set shouldBlockPrivateAddresses(value) {
        this.options.shouldBlockPrivateAddresses = value;
    }
    get shouldBlockPrivateAddresses() {
        return !!this.options.shouldBlockPrivateAddresses;
    }
    get server() {
        return this._server;
    }
}
exports.SocksServer = SocksServer;
function createSocks5ProxyServer(options = {}) {
    const socksServer = new SocksServer(options);
    return socksServer;
}
exports.createSocks5ProxyServer = createSocks5ProxyServer;
exports.EVENTS = __importStar(require("./events"));
//# sourceMappingURL=index.js.map