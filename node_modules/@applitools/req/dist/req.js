import { AbortController } from 'abort-controller';
import { stop } from './stop.js';
import { makeProxyAgent } from './proxy-agent.js';
import globalFetch, { Request, Headers, Response } from 'node-fetch';
import * as utils from '@applitools/utils';
/**
 * Helper function that will create {@link req} function with predefined options
 * @example const req = makeReq({baseUrl: 'http://localhost:2107'})
 */
export function makeReq(baseOptions) {
    return (location, options) => req(location, mergeOptions(baseOptions, options !== null && options !== void 0 ? options : {}));
}
export async function req(input, ...requestOptions) {
    const options = mergeOptions({}, ...requestOptions);
    if (options.hooks)
        options.hooks = utils.types.isArray(options.hooks) ? options.hooks : [options.hooks];
    if (options.retry)
        options.retry = utils.types.isArray(options.retry) ? options.retry : [options.retry];
    if (options.headers)
        options.headers = Object.fromEntries(Object.entries(options.headers).filter(([_, value]) => value));
    const controller = new AbortController();
    const timeout = options.timeout ? setTimeout(() => controller.abort(), options.timeout) : null;
    try {
        return await req(input, options);
    }
    finally {
        if (timeout)
            clearTimeout(timeout);
    }
    async function req(input, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalFetch;
        if (options.signal)
            options.signal.onabort = () => controller.abort();
        const url = new URL(String((_b = input.url) !== null && _b !== void 0 ? _b : input), options.baseUrl);
        if (options.query) {
            Object.entries(options.query).forEach(([key, value]) => {
                if (!utils.types.isNull(value))
                    url.searchParams.set(key, String(value));
            });
        }
        const extraHeaders = {};
        if (utils.types.isPlainObject(options.body) || utils.types.isArray(options.body) || options.body === null) {
            options.body = JSON.stringify(options.body);
            extraHeaders['content-type'] = 'application/json';
        }
        let request = new Request(url, {
            method: (_c = options.method) !== null && _c !== void 0 ? _c : input.method,
            headers: {
                ...extraHeaders,
                ...Object.fromEntries((_e = (_d = input.headers) === null || _d === void 0 ? void 0 : _d.entries()) !== null && _e !== void 0 ? _e : []),
                ...Object.fromEntries(new Headers(options.headers).entries()),
            },
            body: (_f = options.body) !== null && _f !== void 0 ? _f : input.body,
            highWaterMark: 1024 * 1024 * 100 + 1,
            agent: makeProxyAgent(options.proxy),
            signal: controller.signal,
        });
        request = await beforeRequest({ request, options });
        try {
            let response = await fetch(request);
            // if the request has to be retried due to status code
            const retry = await ((_g = options.retry) === null || _g === void 0 ? void 0 : _g.reduce(async (prev, retry) => {
                var _a, _b;
                const result = await prev;
                return (result !== null && result !== void 0 ? result : ((((_a = retry.statuses) === null || _a === void 0 ? void 0 : _a.includes(response.status)) || (await ((_b = retry.validate) === null || _b === void 0 ? void 0 : _b.call(retry, { response })))) &&
                    (!retry.limit || !retry.attempt || retry.attempt < retry.limit)
                    ? retry
                    : null));
            }, Promise.resolve(null)));
            if (retry) {
                (_h = retry.attempt) !== null && _h !== void 0 ? _h : (retry.attempt = 0);
                const delay = response.headers.has('Retry-After')
                    ? Number(response.headers.get('Retry-After')) * 1000
                    : utils.types.isArray(retry.timeout)
                        ? retry.timeout[Math.min(retry.attempt, retry.timeout.length - 1)]
                        : (_j = retry.timeout) !== null && _j !== void 0 ? _j : 0;
                await utils.general.sleep(delay);
                retry.attempt += 1;
                const retryRequest = await beforeRetry({ request, response, attempt: retry.attempt, stop, options });
                if (retryRequest !== stop) {
                    return req(retryRequest, options);
                }
            }
            response = await afterResponse({ request, response, options });
            return response;
        }
        catch (error) {
            // if the request has to be retried due to network error
            const retry = await ((_k = options.retry) === null || _k === void 0 ? void 0 : _k.reduce((prev, retry) => {
                return prev.then(async (result) => {
                    var _a, _b;
                    return (result !== null && result !== void 0 ? result : ((((_a = retry.codes) === null || _a === void 0 ? void 0 : _a.includes(error.code)) || (await ((_b = retry.validate) === null || _b === void 0 ? void 0 : _b.call(retry, { error })))) &&
                        (!retry.limit || !retry.attempt || retry.attempt < retry.limit)))
                        ? retry
                        : null;
                });
            }, Promise.resolve(null)));
            if (retry) {
                (_l = retry.attempt) !== null && _l !== void 0 ? _l : (retry.attempt = 0);
                const delay = utils.types.isArray(retry.timeout)
                    ? retry.timeout[Math.min(retry.attempt, retry.timeout.length)]
                    : (_m = retry.timeout) !== null && _m !== void 0 ? _m : 0;
                await utils.general.sleep(delay);
                retry.attempt = retry.attempt + 1;
                const retryRequest = await beforeRetry({ request, error, attempt: retry.attempt, stop, options });
                if (retryRequest !== stop) {
                    return req(retryRequest, options);
                }
            }
            error = await afterError({ request, error, options });
            throw error;
        }
        finally {
            if (options.signal)
                options.signal.onabort = null;
        }
    }
}
function mergeOptions(baseOptions, ...options) {
    var _a;
    const mergedOptions = options.reduce((baseOptions, options) => ({
        ...baseOptions,
        ...options,
        query: { ...baseOptions.query, ...options === null || options === void 0 ? void 0 : options.query },
        headers: { ...baseOptions.headers, ...options === null || options === void 0 ? void 0 : options.headers },
        retry: [
            ...(baseOptions.retry ? [].concat(baseOptions.retry) : []),
            ...((options === null || options === void 0 ? void 0 : options.retry) ? [].concat(options.retry) : []),
        ],
        hooks: [
            ...(baseOptions.hooks ? [].concat(baseOptions.hooks) : []),
            ...((options === null || options === void 0 ? void 0 : options.hooks) ? [].concat(options.hooks) : []),
        ],
    }), baseOptions);
    return ((_a = mergedOptions.hooks) !== null && _a !== void 0 ? _a : []).reduce((options, hooks) => { var _a, _b; return (_b = (_a = hooks.afterOptionsMerged) === null || _a === void 0 ? void 0 : _a.call(hooks, { options })) !== null && _b !== void 0 ? _b : options; }, mergedOptions);
}
function beforeRequest({ request, options, ...rest }) {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []).reduce(async (request, hooks) => {
        var _a, _b;
        request = await request;
        const result = await ((_a = hooks.beforeRequest) === null || _a === void 0 ? void 0 : _a.call(hooks, { request, options, ...rest }));
        if (!result)
            return request;
        else if (utils.types.instanceOf(result, Request))
            return result;
        else if (utils.types.has(result, 'url'))
            return new Request(result.url, (_b = result.request) !== null && _b !== void 0 ? _b : result);
        else
            return new Request(result.request, result);
    }, request);
}
function beforeRetry({ request, options, ...rest }) {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []).reduce(async (request, hooks) => {
        var _a, _b;
        request = await request;
        if (request === stop)
            return request;
        const result = await ((_a = hooks.beforeRetry) === null || _a === void 0 ? void 0 : _a.call(hooks, { request, options, ...rest }));
        if (result === stop)
            return result;
        else if (!result)
            return request;
        else if (utils.types.instanceOf(result, Request))
            return result;
        else if (utils.types.has(result, 'url'))
            return new Request(result.url, (_b = result.request) !== null && _b !== void 0 ? _b : result);
        else
            return new Request(result.request, result);
    }, request);
}
function afterResponse({ response, options, ...rest }) {
    var _a, _b;
    return (_b = (((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []))) === null || _b === void 0 ? void 0 : _b.reduce(async (response, hooks) => {
        var _a, _b, _c, _d;
        response = await response;
        const result = await ((_a = hooks.afterResponse) === null || _a === void 0 ? void 0 : _a.call(hooks, { response, options, ...rest }));
        if (!result)
            return response;
        else if (utils.types.instanceOf(result, Response))
            return result;
        else
            return new Response((_b = result.body) !== null && _b !== void 0 ? _b : (_c = result.response) === null || _c === void 0 ? void 0 : _c.body, (_d = result.response) !== null && _d !== void 0 ? _d : result);
    }, response);
}
function afterError({ error, options, ...rest }) {
    var _a, _b;
    return (_b = (((_a = options === null || options === void 0 ? void 0 : options.hooks) !== null && _a !== void 0 ? _a : []))) === null || _b === void 0 ? void 0 : _b.reduce(async (error, hooks) => {
        var _a;
        error = await error;
        return (await ((_a = hooks.afterError) === null || _a === void 0 ? void 0 : _a.call(hooks, { error, options, ...rest }))) || error;
    }, error);
}
