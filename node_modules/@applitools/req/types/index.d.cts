export type Stop = typeof stop;
export class Request {
    constructor(input: URL | (string | Request), init?: undefined | RequestInit);
    readonly headers: Headers;
    readonly method: string;
    readonly redirect: "error" | "follow" | "manual";
    readonly signal: { readonly aborted: boolean; addEventListener: (type: "abort", listener: () => void) => void; removeEventListener: (type: "abort", listener: () => void) => void; };
    readonly url: string;
    readonly referrer: string;
    readonly referrerPolicy: "" | "no-referrer" | "no-referrer-when-downgrade" | "same-origin" | "origin" | "strict-origin" | "origin-when-cross-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
    clone(): Request;
    readonly body: null | NodeJS.ReadableStream;
    readonly bodyUsed: boolean;
    readonly size: number;
    buffer(): Promise<Buffer>;
    arrayBuffer(): Promise<ArrayBuffer>;
    formData(): Promise<FormData>;
    blob(): Promise<Blob>;
    json(): Promise<unknown>;
    text(): Promise<string>;
}
export interface RequestInit {
    body?: undefined | null | BodyInit;
    headers?: undefined | HeadersInit;
    method?: undefined | string;
    redirect?: undefined | ("error" | "follow" | "manual");
    signal?: undefined | null | { readonly aborted: boolean; addEventListener: (type: "abort", listener: () => void) => void; removeEventListener: (type: "abort", listener: () => void) => void; };
    referrer?: undefined | string;
    referrerPolicy?: undefined | ("" | "no-referrer" | "no-referrer-when-downgrade" | "same-origin" | "origin" | "strict-origin" | "origin-when-cross-origin" | "strict-origin-when-cross-origin" | "unsafe-url");
    agent?: undefined | boolean | import('http').Agent | ((parsedUrl: URL) => undefined | boolean | import('http').Agent);
    compress?: undefined | boolean;
    counter?: undefined | number;
    follow?: undefined | number;
    hostname?: undefined | string;
    port?: undefined | number;
    protocol?: undefined | string;
    size?: undefined | number;
    highWaterMark?: undefined | number;
    insecureHTTPParser?: undefined | boolean;
}
export class Response {
    static error(): Response;
    static redirect(url: string, status?: undefined | number): Response;
    static json(data: any, init?: undefined | ResponseInit): Response;
    constructor(body?: undefined | null | BodyInit, init?: undefined | ResponseInit);
    readonly headers: Headers;
    readonly ok: boolean;
    readonly redirected: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly type: "default" | "error" | "basic" | "cors" | "opaque" | "opaqueredirect";
    readonly url: string;
    clone(): Response;
    readonly body: null | NodeJS.ReadableStream;
    readonly bodyUsed: boolean;
    readonly size: number;
    buffer(): Promise<Buffer>;
    arrayBuffer(): Promise<ArrayBuffer>;
    formData(): Promise<FormData>;
    blob(): Promise<Blob>;
    json(): Promise<unknown>;
    text(): Promise<string>;
}
export interface ResponseInit {
    headers?: undefined | HeadersInit;
    status?: undefined | number;
    statusText?: undefined | string;
}
export class Headers {
    constructor(init?: undefined | HeadersInit);
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): null | string;
    has(name: string): boolean;
    set(name: string, value: string): void;
    forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: any): void;
    entries(): IterableIterator<[string, string]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string>;
    raw(): Record<string, Array<string>>;
    [Symbol.iterator](): IterableIterator<[string, string]>;
}
export type HeadersInit = Record<string, string> | Headers | Iterable<[string, string]> | Iterable<Iterable<string>>;
export type BodyInit = string | NodeJS.ReadableStream | Blob | Buffer | URLSearchParams | FormData;
export default req;
export type Fetch = (url: URL | (string | Request), init?: undefined | RequestInit) => Promise<Response>;
export interface Options {
    baseUrl?: undefined | string;
    method?: undefined | string;
    query?: undefined | Record<string, undefined | string | number | boolean>;
    headers?: undefined | Record<string, undefined | string | Array<string>>;
    body?: undefined | null | string | Array<any> | NodeJS.ReadableStream | ArrayBufferView | Record<string, any>;
    proxy?: undefined | Proxy | ((url: URL) => undefined | Proxy);
    timeout?: undefined | number;
    retry?: undefined | Retry | Array<Retry>;
    hooks?: undefined | Hooks<this> | Array<Hooks<this>>;
    signal?: undefined | AbortSignal;
    fetch?: undefined | Fetch;
}
export interface Retry {
    limit?: undefined | number;
    timeout?: undefined | number | Array<number>;
    validate?: undefined | ((options: { response?: undefined | Response; error?: undefined | Error; }) => boolean | Promise<boolean>);
    statuses?: undefined | Array<number>;
    codes?: undefined | Array<string>;
    attempt?: undefined | number;
}
export interface Proxy {
    url: string;
    username?: undefined | string;
    password?: undefined | string;
}
export interface Hooks<TOptions extends Options = Options> {
    afterOptionsMerged?(options: { options: TOptions; }): void | TOptions;
    beforeRequest?(options: { request: Request; options?: undefined | TOptions; }): void | Request | (RequestInit & { request: Request; }) | (RequestInit & { url: string | URL; request?: undefined | Request; }) | Promise<void | Request | (RequestInit & { request: Request; }) | (RequestInit & { url: string | URL; request?: undefined | Request; })>;
    beforeRetry?(options: {
        request: Request;
        attempt: number;
        stop: Stop;
        response?: undefined | Response;
        error?: undefined | Error;
        options?: undefined | TOptions;
    }): void | Stop | Request | (RequestInit & { request: Request; }) | (RequestInit & { url: string | URL; request?: undefined | Request; }) | Promise<void | Stop | Request | (RequestInit & { request: Request; }) | (RequestInit & { url: string | URL; request?: undefined | Request; })>;
    afterResponse?(options: { request: Request; response: Response; options?: undefined | TOptions; }): void | Response | (ResponseInit & { response?: undefined | Response; body?: undefined | null | BodyInit; }) | Promise<void | Response | (ResponseInit & { response?: undefined | Response; body?: undefined | null | BodyInit; })>;
    afterError?(options: { request: Request; error: Error; options?: undefined | TOptions; }): void | Error | Promise<void | Error>;
}
export type AbortSignal = { readonly aborted: boolean; onabort: null | ((event: any) => void); addEventListener: (type: "abort", listener: () => void) => void; removeEventListener: (type: "abort", listener: () => void) => void; };
export function makeReq<TOptions extends Options = Options, TBaseOptions extends TOptions = TOptions>(baseOptions: Partial<TBaseOptions>): Req<TOptions>;
export function req(input: string | URL | Request, ...requestOptions: Array<Options>): Promise<Response>;
export type Req<TOptions extends Options = Options> = (input: string | URL | Request, ...options: Array<TOptions>) => Promise<Response>;
