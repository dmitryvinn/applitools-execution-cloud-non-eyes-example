"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.switchWorld = exports.getWorlds = exports.getCurrentWorld = exports.performAction = exports.getElementAttribute = exports.getElementRegion = exports.setOrientation = exports.getOrientation = exports.getSystemBars = exports.hover = exports.click = exports.takeScreenshot = exports.visit = exports.getUrl = exports.getTitle = exports.getDriverInfo = exports.getCapabilities = exports.getCookies = exports.setWindowSize = exports.getWindowSize = exports.getElementText = exports.setElementText = exports.findElements = exports.findElement = exports.childContext = exports.parentContext = exports.mainContext = exports.executeScript = exports.isEqualElements = exports.isStaleElementError = exports.extractHostName = exports.untransformSelector = exports.transformSelector = exports.transformElement = exports.transformDriver = exports.isSelector = exports.isShadowRoot = exports.isElement = exports.isDriver = void 0;
const url_1 = require("url");
const utils = __importStar(require("@applitools/utils"));
const webdriver_1 = __importStar(require("webdriver"));
const http_proxy_agent_1 = __importDefault(require("http-proxy-agent"));
const https_proxy_agent_1 = __importDefault(require("https-proxy-agent"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
// #region HELPERS
const LEGACY_ELEMENT_ID = 'ELEMENT';
const ELEMENT_ID = 'element-6066-11e4-a52e-4f735466cecf';
const SHADOW_ROOT_ID = 'shadow-6066-11e4-a52e-4f735466cecf';
const W3C_CAPABILITIES = ['platformName', 'platformVersion'];
const W3C_SECONDARY_CAPABILITIES = ['pageLoadStrategy'];
const W3C_SAFARI_CAPABILITIES = ['browserVersion', 'setWindowRect'];
const APPIUM_CAPABILITIES = ['appiumVersion', 'deviceType', 'deviceOrientation', 'deviceName', 'automationName'];
const LEGACY_APPIUM_CAPABILITIES = ['appium-version', 'device-type', 'device-orientation'];
const CHROME_CAPABILITIES = ['chrome', 'goog:chromeOptions'];
const MOBILE_BROWSER_NAMES = ['ipad', 'iphone', 'android'];
const ANDROID_PLATFORM_NAME = 'android';
const ANDROID_AUTOMATION_NAME = 'uiautomator2';
function extractElementId(element) {
    var _a;
    return ((_a = element[ELEMENT_ID]) !== null && _a !== void 0 ? _a : element[LEGACY_ELEMENT_ID]);
}
function extractShadowRootId(shadowRoot) {
    return shadowRoot[SHADOW_ROOT_ID];
}
function extractEnvironment(capabilities) {
    var _a, _b, _c, _d;
    const isAppium = APPIUM_CAPABILITIES.some(capability => capabilities.hasOwnProperty(capability)) ||
        APPIUM_CAPABILITIES.some(capability => capabilities.hasOwnProperty(`appium:${capability}`));
    const isChrome = CHROME_CAPABILITIES.includes((_a = capabilities.browserName) === null || _a === void 0 ? void 0 : _a.toLowerCase());
    const isW3C = isAppium ||
        W3C_SECONDARY_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability)) ||
        W3C_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability)) ||
        W3C_SAFARI_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability));
    const isMobile = capabilities.browserName === '' ||
        isAppium ||
        LEGACY_APPIUM_CAPABILITIES.some(capability => capabilities.hasOwnProperty(capability)) ||
        MOBILE_BROWSER_NAMES.includes((_b = capabilities.browserName) === null || _b === void 0 ? void 0 : _b.toLowerCase());
    const isAndroid = ((_c = capabilities.platformName) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === ANDROID_PLATFORM_NAME ||
        ((_d = capabilities.automationName) === null || _d === void 0 ? void 0 : _d.toLowerCase()) === ANDROID_AUTOMATION_NAME;
    return {
        isAndroid,
        isChrome,
        isMobile,
        isW3C,
    };
}
// #endregion
// #region UTILITY
function isDriver(driver) {
    if (!driver)
        return false;
    return utils.types.has(driver, ['sessionId', 'serverUrl']) || utils.types.instanceOf(driver, 'Browser');
}
exports.isDriver = isDriver;
function isElement(element) {
    var _a;
    if (!element)
        return false;
    return Boolean((_a = element.elementId) !== null && _a !== void 0 ? _a : extractElementId(element));
}
exports.isElement = isElement;
function isShadowRoot(shadowRoot) {
    if (!shadowRoot)
        return false;
    return Boolean(extractShadowRootId(shadowRoot));
}
exports.isShadowRoot = isShadowRoot;
function isSelector(selector) {
    if (!selector)
        return false;
    return utils.types.has(selector, ['using', 'value']);
}
exports.isSelector = isSelector;
function transformDriver(driver) {
    var _a, _b, _c;
    if (!utils.types.has(driver, ['sessionId', 'serverUrl']))
        return driver;
    const url = new URL(driver.serverUrl);
    const environment = extractEnvironment(driver.capabilities);
    const options = {
        sessionId: driver.sessionId,
        protocol: url.protocol ? url.protocol.replace(/:$/, '') : undefined,
        hostname: url.hostname,
        port: Number(url.port) || undefined,
        path: url.pathname,
        capabilities: driver.capabilities,
        logLevel: 'silent',
        ...environment,
    };
    if ((_a = driver.proxy) === null || _a === void 0 ? void 0 : _a.url) {
        const proxyUrl = new URL(driver.proxy.url);
        proxyUrl.username = (_b = driver.proxy.username) !== null && _b !== void 0 ? _b : proxyUrl.username;
        proxyUrl.password = (_c = driver.proxy.password) !== null && _c !== void 0 ? _c : proxyUrl.password;
        const proxyOptions = { ...(0, url_1.parse)(proxyUrl.href), rejectUnauthorized: false };
        const httpAgent = (0, http_proxy_agent_1.default)(proxyOptions);
        const httpsAgent = (0, https_proxy_agent_1.default)(proxyOptions);
        httpsAgent.callback = utils.general.wrap(httpsAgent.callback.bind(httpsAgent), (fn, request, options, ...rest) => {
            return fn(request, { ...options, rejectUnauthorized: false }, ...rest);
        });
        options.agent = { http: httpAgent, https: httpsAgent };
    }
    else {
        const httpAgent = http_1.default.globalAgent;
        const httpsAgent = new https_1.default.Agent({ rejectUnauthorized: false });
        options.agent = { http: httpAgent, https: httpsAgent };
    }
    if (!options.port) {
        if (options.protocol === 'http')
            options.port = 80;
        if (options.protocol === 'https')
            options.port = 443;
    }
    const additionalCommands = {
        _getWindowSize: {
            value: (0, webdriver_1.command)('GET', '/session/:sessionId/window/current/size', {
                command: '_getWindowSize',
                description: '',
                ref: '',
                parameters: [],
            }),
        },
        _setWindowSize: {
            value: (0, webdriver_1.command)('POST', '/session/:sessionId/window/current/size', {
                command: '_setWindowSize',
                parameters: [
                    { name: 'width', type: 'number', required: true, description: '' },
                    { name: 'height', type: 'number', required: true, description: '' },
                ],
                description: '',
                ref: '',
            }),
        },
        setWindowPosition: {
            value: (0, webdriver_1.command)('POST', '/session/:sessionId/window/current/position', {
                command: 'setWindowPosition',
                parameters: [
                    { name: 'x', type: 'number', required: true, description: '' },
                    { name: 'y', type: 'number', required: true, description: '' },
                ],
                description: '',
                ref: '',
            }),
        },
    };
    return webdriver_1.default.attachToSession(options, undefined, additionalCommands);
}
exports.transformDriver = transformDriver;
function transformElement(element) {
    const elementId = utils.types.has(element, 'elementId') ? element.elementId : extractElementId(element);
    return { [ELEMENT_ID]: elementId, [LEGACY_ELEMENT_ID]: elementId };
}
exports.transformElement = transformElement;
function transformSelector(selector) {
    if (utils.types.isString(selector)) {
        return { using: 'css selector', value: selector };
    }
    else if (utils.types.has(selector, 'selector')) {
        if (!utils.types.isString(selector.selector))
            return selector.selector;
        return {
            using: utils.types.isNull(selector.type) || selector.type === 'css' ? 'css selector' : selector.type,
            value: selector.selector,
        };
    }
    else {
        return selector;
    }
}
exports.transformSelector = transformSelector;
function untransformSelector(selector) {
    if (utils.types.has(selector, ['using', 'value'])) {
        return { type: selector.using === 'css selector' ? 'css' : selector.using, selector: selector.value };
    }
    return selector;
}
exports.untransformSelector = untransformSelector;
function extractHostName(driver) {
    var _a, _b;
    return (_b = (_a = driver.options) === null || _a === void 0 ? void 0 : _a.hostname) !== null && _b !== void 0 ? _b : null;
}
exports.extractHostName = extractHostName;
function isStaleElementError(error) {
    if (!error)
        return false;
    const errOrResult = error.originalError || error;
    return errOrResult instanceof Error && errOrResult.name === 'stale element reference';
}
exports.isStaleElementError = isStaleElementError;
// #endregion
// #region COMMANDS
async function isEqualElements(_driver, element1, element2) {
    if (!element1 || !element2)
        return false;
    const elementId1 = extractElementId(element1);
    const elementId2 = extractElementId(element2);
    return elementId1 === elementId2;
}
exports.isEqualElements = isEqualElements;
async function executeScript(driver, script, arg) {
    script = utils.types.isFunction(script) ? `return (${script}).apply(null, arguments)` : script;
    return driver.executeScript(script, [arg]);
}
exports.executeScript = executeScript;
async function mainContext(driver) {
    await driver.switchToFrame(null);
    return driver;
}
exports.mainContext = mainContext;
async function parentContext(driver) {
    await driver.switchToParentFrame();
    return driver;
}
exports.parentContext = parentContext;
async function childContext(driver, element) {
    await driver.switchToFrame(element);
    return driver;
}
exports.childContext = childContext;
async function findElement(driver, selector, parent) {
    const parentId = parent ? (isShadowRoot(parent) ? extractShadowRootId(parent) : extractElementId(parent)) : null;
    try {
        const element = parentId
            ? await driver.findElementFromElement(parentId, selector.using, selector.value)
            : await driver.findElement(selector.using, selector.value);
        return isElement(element) ? element : null;
    }
    catch {
        return null;
    }
}
exports.findElement = findElement;
async function findElements(driver, selector, parent) {
    const parentId = parent ? (isShadowRoot(parent) ? extractShadowRootId(parent) : extractElementId(parent)) : null;
    return parentId
        ? await driver.findElementsFromElement(parentId, selector.using, selector.value)
        : await driver.findElements(selector.using, selector.value);
}
exports.findElements = findElements;
async function setElementText(driver, element, text) {
    await driver.elementClear(extractElementId(element));
    await driver.elementSendKeys(extractElementId(element), text);
}
exports.setElementText = setElementText;
async function getElementText(driver, element) {
    return driver.getElementText(extractElementId(element));
}
exports.getElementText = getElementText;
async function getWindowSize(driver) {
    try {
        const rect = await driver.getWindowRect();
        return { width: rect.width, height: rect.height };
    }
    catch {
        return driver._getWindowSize();
    }
}
exports.getWindowSize = getWindowSize;
async function setWindowSize(driver, size) {
    try {
        await driver.setWindowRect(0, 0, size.width, size.height);
    }
    catch {
        await driver.setWindowPosition(0, 0);
        await driver._setWindowSize(size.width, size.height);
    }
}
exports.setWindowSize = setWindowSize;
async function getCookies(driver, context) {
    if (context)
        return driver.getAllCookies();
    const response = await driver.sendCommandAndGetResult('Network.getAllCookies', {});
    const cookies = response.cookies;
    return cookies.map((cookie) => {
        const copy = { ...cookie, expiry: cookie.expires };
        delete copy.expires;
        delete copy.size;
        delete copy.priority;
        delete copy.session;
        delete copy.sameParty;
        delete copy.sourceScheme;
        delete copy.sourcePort;
        return copy;
    });
}
exports.getCookies = getCookies;
async function getCapabilities(driver) {
    var _a;
    try {
        const capabilities = await ((_a = driver.getSession) === null || _a === void 0 ? void 0 : _a.call(driver));
        return utils.types.isObject(capabilities) ? capabilities : driver.capabilities;
    }
    catch (error) {
        if (/Cannot call non W3C standard command while in W3C mode/i.test(error.message))
            return driver.capabilities;
        throw new Error(`Unable to retrieve capabilities due to an error. The original error is ${error.message}`);
    }
}
exports.getCapabilities = getCapabilities;
async function getDriverInfo(driver) {
    return { sessionId: driver.sessionId };
}
exports.getDriverInfo = getDriverInfo;
async function getTitle(driver) {
    return driver.getTitle();
}
exports.getTitle = getTitle;
async function getUrl(driver) {
    return driver.getUrl();
}
exports.getUrl = getUrl;
async function visit(driver, url) {
    await driver.navigateTo(url);
}
exports.visit = visit;
async function takeScreenshot(driver) {
    return driver.takeScreenshot();
}
exports.takeScreenshot = takeScreenshot;
async function click(driver, element) {
    const resolvedElement = isSelector(element) ? await findElement(driver, element) : element;
    if (resolvedElement)
        await driver.elementClick(extractElementId(resolvedElement));
}
exports.click = click;
async function hover(driver, element) {
    if (!driver.isW3C)
        return await driver.moveToElement(extractElementId(element));
    const { x, y, width, height } = await driver.getElementRect(extractElementId(element));
    const { scrollX, scrollY } = await driver.executeScript('return {scrollX:window.pageXOffset,scrollY:window.pageYOffset}', []);
    const offsetX = Math.floor(x - scrollX + width / 2);
    const offsetY = Math.floor(y - scrollY + height / 2);
    await driver.performActions([
        {
            type: 'pointer',
            id: 'mouse',
            parameters: { pointerType: 'mouse' },
            actions: [{ type: 'pointerMove', duration: 0, x: offsetX, y: offsetY }],
        },
    ]);
}
exports.hover = hover;
// #endregion
// #region APPIUM COMMANDS
async function getSystemBars(browser) {
    return browser.getSystemBars();
}
exports.getSystemBars = getSystemBars;
async function getOrientation(browser) {
    const orientation = await browser.getOrientation();
    return orientation.toLowerCase();
}
exports.getOrientation = getOrientation;
async function setOrientation(browser, orientation) {
    return await browser.setOrientation(orientation);
}
exports.setOrientation = setOrientation;
async function getElementRegion(driver, element) {
    return driver.getElementRect(extractElementId(element));
}
exports.getElementRegion = getElementRegion;
async function getElementAttribute(driver, element, attr) {
    return driver.getElementAttribute(extractElementId(element), attr);
}
exports.getElementAttribute = getElementAttribute;
async function performAction(driver, steps) {
    return driver.touchPerform(steps.map(({ action, ...options }) => ({ action, options })));
}
exports.performAction = performAction;
async function getCurrentWorld(driver) {
    const world = await driver.getContext();
    return utils.types.isString(world) ? world : world.id;
}
exports.getCurrentWorld = getCurrentWorld;
async function getWorlds(driver) {
    const worlds = await driver.getContexts();
    return worlds.map(world => (utils.types.isString(world) ? world : world.id));
}
exports.getWorlds = getWorlds;
async function switchWorld(driver, id) {
    await driver.switchContext(id);
}
exports.switchWorld = switchWorld;
// #endregion
// #region TESTING
const browserOptionsNames = {
    chrome: 'goog:chromeOptions',
    firefox: 'moz:firefoxOptions',
};
async function build(env) {
    const parseEnv = require('@applitools/test-utils/src/parse-env');
    const { browser = '', capabilities, url, proxy, configurable = true, args = [], headless, logLevel = 'silent', } = parseEnv(env);
    const options = {
        capabilities: { browserName: browser, ...capabilities },
        logLevel,
    };
    options.protocol = url.protocol ? url.protocol.replace(/:$/, '') : undefined;
    options.hostname = url.hostname;
    if (url.port)
        options.port = Number(url.port);
    else if (options.protocol === 'http')
        options.port = 80;
    else if (options.protocol === 'https')
        options.port = 443;
    options.path = url.pathname;
    if (configurable) {
        const browserOptionsName = browserOptionsNames[browser || options.capabilities.browserName];
        if (browserOptionsName) {
            const browserOptions = options.capabilities[browserOptionsName] || {};
            browserOptions.args = [...(browserOptions.args || []), ...args];
            if (headless)
                browserOptions.args.push('headless');
            options.capabilities[browserOptionsName] = browserOptions;
        }
    }
    if (proxy) {
        options.capabilities.proxy = {
            proxyType: 'manual',
            httpProxy: proxy.http || proxy.server,
            sslProxy: proxy.https || proxy.server,
            ftpProxy: proxy.ftp,
            noProxy: proxy.bypass.join(','),
        };
    }
    options.agent = { https: require('https').Agent({ rejectUnauthorized: false }) };
    const driver = await webdriver_1.default.newSession(options);
    return [driver, () => driver.deleteSession()];
}
exports.build = build;
// #endregion
