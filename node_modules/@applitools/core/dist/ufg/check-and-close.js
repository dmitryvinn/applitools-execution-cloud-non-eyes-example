"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCheckAndClose = void 0;
const driver_1 = require("@applitools/driver");
const take_dom_snapshots_1 = require("./utils/take-dom-snapshots");
const wait_for_lazy_load_1 = require("../automation/utils/wait-for-lazy-load");
const to_base_check_settings_1 = require("../automation/utils/to-base-check-settings");
const generate_safe_selectors_1 = require("./utils/generate-safe-selectors");
const uniquify_renderers_1 = require("./utils/uniquify-renderers");
const abort_error_1 = require("../errors/abort-error");
const utils = __importStar(require("@applitools/utils"));
const chalk_1 = __importDefault(require("chalk"));
function makeCheckAndClose({ eyes, target: defaultTarget, spec, signal, logger: mainLogger, }) {
    return async function checkAndClose({ target = defaultTarget, settings = {}, logger = mainLogger, }) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        logger = logger.extend(mainLogger);
        logger.log('Command "checkAndClose" is called with settings', settings);
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            logger.warn('Command "checkAndClose" was called after test was already aborted');
            throw new abort_error_1.AbortError('Command "checkAndClose" was called after test was already aborted');
        }
        const { elementReferencesToCalculate, elementReferenceToTarget, getBaseCheckSettings } = (0, to_base_check_settings_1.toBaseCheckSettings)({
            settings,
        });
        const uniqueRenderers = (0, uniquify_renderers_1.uniquifyRenderers)((_a = settings.renderers) !== null && _a !== void 0 ? _a : []);
        const ufgClient = await eyes.core.getUFGClient({
            config: { ...eyes.test.ufgServer },
            concurrency: uniqueRenderers.length || 5,
            logger,
        });
        let snapshots;
        let snapshotUrl;
        let snapshotTitle;
        let userAgent;
        let regionToTarget;
        let scrollRootSelector;
        let selectorsToCalculate;
        const driver = spec && (0, driver_1.isDriver)(target, spec) ? await (0, driver_1.makeDriver)({ spec, driver: target, logger }) : null;
        if (driver) {
            const environment = await driver.getEnvironment();
            if (uniqueRenderers.length === 0) {
                if (environment.isWeb) {
                    const viewportSize = await driver.getViewportSize();
                    uniqueRenderers.push({ name: 'chrome', ...viewportSize });
                }
                else {
                    // TODO add default nmg renderers
                }
            }
            let cleanupGeneratedSelectors;
            if (environment.isWeb) {
                userAgent = await driver.getUserAgentLegacy();
                const generated = await (0, generate_safe_selectors_1.generateSafeSelectors)({
                    context: driver.currentContext,
                    elementReferences: [
                        ...(elementReferenceToTarget ? [elementReferenceToTarget] : []),
                        ...(settings.scrollRootElement ? [settings.scrollRootElement] : []),
                        ...elementReferencesToCalculate,
                    ],
                });
                cleanupGeneratedSelectors = generated.cleanupGeneratedSelectors;
                selectorsToCalculate = generated.selectors;
                if (elementReferenceToTarget) {
                    if (!((_b = selectorsToCalculate[0]) === null || _b === void 0 ? void 0 : _b.safeSelector))
                        throw new Error('Target element not found');
                    regionToTarget = selectorsToCalculate[0].safeSelector;
                    selectorsToCalculate = selectorsToCalculate.slice(1);
                }
                if (settings.scrollRootElement) {
                    scrollRootSelector = (_c = selectorsToCalculate[0].safeSelector) !== null && _c !== void 0 ? _c : undefined;
                    selectorsToCalculate = selectorsToCalculate.slice(1);
                }
            }
            else {
                regionToTarget = (0, driver_1.isSelector)(elementReferenceToTarget)
                    ? (_e = (_d = spec === null || spec === void 0 ? void 0 : spec.untransformSelector) === null || _d === void 0 ? void 0 : _d.call(spec, settings.scrollRootElement)) !== null && _e !== void 0 ? _e : undefined
                    : undefined;
                scrollRootSelector = (0, driver_1.isSelector)(settings.scrollRootElement)
                    ? (_g = (_f = spec === null || spec === void 0 ? void 0 : spec.untransformSelector) === null || _f === void 0 ? void 0 : _f.call(spec, settings.scrollRootElement)) !== null && _g !== void 0 ? _g : undefined
                    : undefined;
            }
            const currentContext = driver.currentContext;
            const snapshotOptions = {
                settings: {
                    ...eyes.test.server,
                    waitBeforeCapture: settings.waitBeforeCapture,
                    disableBrowserFetching: settings.disableBrowserFetching,
                    layoutBreakpoints: settings.layoutBreakpoints,
                    renderers: uniqueRenderers,
                    skipResources: ufgClient.getCachedResourceUrls(),
                },
                hooks: {
                    async beforeSnapshots() {
                        if (settings.lazyLoad && environment.isWeb) {
                            await (0, wait_for_lazy_load_1.waitForLazyLoad)({
                                context: driver.currentContext,
                                settings: settings.lazyLoad !== true ? settings.lazyLoad : {},
                                logger,
                            });
                        }
                    },
                },
                provides: {
                    getChromeEmulationDevices: ufgClient.getChromeEmulationDevices,
                    getIOSDevices: ufgClient.getIOSDevices,
                },
            };
            if (environment.isWeb) {
                snapshots = await (0, take_dom_snapshots_1.takeDomSnapshots)({ driver, ...snapshotOptions, logger });
            }
            else {
                const nmlClient = await eyes.core.getNMLClient({ config: eyes.test.server, driver, logger });
                snapshots = (await nmlClient.takeSnapshots({ ...snapshotOptions, logger }));
            }
            await currentContext.focus();
            snapshotUrl = await driver.getUrl();
            snapshotTitle = await driver.getTitle();
            await (cleanupGeneratedSelectors === null || cleanupGeneratedSelectors === void 0 ? void 0 : cleanupGeneratedSelectors());
        }
        else {
            snapshots = !utils.types.isArray(target) ? Array(uniqueRenderers.length).fill(target) : target;
            snapshotUrl = utils.types.has(snapshots[0], 'url') ? snapshots[0].url : undefined;
        }
        regionToTarget !== null && regionToTarget !== void 0 ? regionToTarget : (regionToTarget = (_h = elementReferenceToTarget) !== null && _h !== void 0 ? _h : settings.region);
        selectorsToCalculate !== null && selectorsToCalculate !== void 0 ? selectorsToCalculate : (selectorsToCalculate = elementReferencesToCalculate.map(selector => ({
            originalSelector: selector,
            safeSelector: selector,
        })));
        const promises = uniqueRenderers.map(async (renderer, index) => {
            const rendererLogger = logger.extend({ tags: [`renderer-${utils.general.shortid()}`] });
            if (utils.types.has(renderer, 'name') && renderer.name === 'edge') {
                const message = chalk_1.default.yellow(`The 'edge' option that is being used in your browsers' configuration will soon be deprecated. Please change it to either 'edgelegacy' for the legacy version or to 'edgechromium' for the new Chromium-based version. Please note, when using the built-in BrowserType enum, then the values are BrowserType.EDGE_LEGACY and BrowserType.EDGE_CHROMIUM, respectively.`);
                rendererLogger.console.log(message);
            }
            try {
                if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                    rendererLogger.warn('Command "check" was aborted before rendering');
                    throw new abort_error_1.AbortError('Command "check" was aborted before rendering');
                }
                const { cookies, ...snapshot } = snapshots[index];
                const snapshotType = utils.types.has(snapshot, 'cdt') ? 'web' : 'native';
                const renderTargetPromise = ufgClient.createRenderTarget({
                    snapshot,
                    settings: {
                        renderer,
                        referer: snapshotUrl,
                        cookies,
                        proxy: eyes.test.server.proxy,
                        autProxy: settings.autProxy,
                        userAgent,
                    },
                    logger: rendererLogger,
                });
                const [baseEyes] = await eyes.getBaseEyes({ settings: { renderer, type: snapshotType }, logger });
                try {
                    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                        rendererLogger.warn('Command "check" was aborted before rendering');
                        throw new abort_error_1.AbortError('Command "check" was aborted before rendering');
                    }
                    else if (!baseEyes.running) {
                        rendererLogger.warn(`Renderer with id ${baseEyes.test.rendererId} was aborted during one of the previous steps`);
                        throw new abort_error_1.AbortError(`Renderer with id "${baseEyes.test.rendererId}" was aborted during one of the previous steps`);
                    }
                    const renderTarget = await renderTargetPromise;
                    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                        rendererLogger.warn('Command "check" was aborted before rendering');
                        throw new abort_error_1.AbortError('Command "check" was aborted before rendering');
                    }
                    else if (!baseEyes.running) {
                        rendererLogger.warn(`Renderer with id ${baseEyes.test.rendererId} was aborted during one of the previous steps`);
                        throw new abort_error_1.AbortError(`Renderer with id "${baseEyes.test.rendererId}" was aborted during one of the previous steps`);
                    }
                    const { renderId, selectorRegions, ...baseTarget } = await ufgClient.render({
                        target: renderTarget,
                        settings: {
                            ...settings,
                            region: regionToTarget,
                            scrollRootElement: scrollRootSelector,
                            selectorsToCalculate: selectorsToCalculate.flatMap(({ safeSelector }) => safeSelector !== null && safeSelector !== void 0 ? safeSelector : []),
                            includeFullPageSize: Boolean(settings.pageId),
                            type: snapshotType,
                            renderer,
                            rendererUniqueId: baseEyes.test.rendererUniqueId,
                            rendererId: baseEyes.test.rendererId,
                        },
                        signal,
                        logger: rendererLogger,
                    });
                    let offset = 0;
                    const baseSettings = getBaseCheckSettings({
                        calculatedRegions: selectorsToCalculate.map(({ originalSelector, safeSelector }) => ({
                            selector: originalSelector !== null && originalSelector !== void 0 ? originalSelector : undefined,
                            regions: safeSelector ? selectorRegions[offset++] : [],
                        })),
                    });
                    baseSettings.renderId = renderId;
                    baseTarget.source = snapshotUrl;
                    baseTarget.name = snapshotTitle;
                    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                        rendererLogger.warn('Command "check" was aborted after rendering');
                        throw new abort_error_1.AbortError('Command "check" was aborted after rendering');
                    }
                    else if (!baseEyes.running) {
                        rendererLogger.warn(`Renderer with id ${baseEyes.test.rendererId} was aborted during one of the previous steps`);
                        throw new abort_error_1.AbortError(`Renderer with id "${baseEyes.test.rendererId}" was aborted during one of the previous steps`);
                    }
                    const [result] = await baseEyes.checkAndClose({
                        target: { ...baseTarget, isTransformed: true },
                        settings: baseSettings,
                        logger: rendererLogger,
                    });
                    return { ...result, userTestId: eyes.test.userTestId, eyes: baseEyes, renderer };
                }
                catch (error) {
                    rendererLogger.error(`Renderer with id ${baseEyes.test.rendererId} failed due to an error`, error);
                    await baseEyes.abort({ logger: rendererLogger });
                    error.info = { eyes: baseEyes };
                    throw error;
                }
            }
            catch (error) {
                rendererLogger.error(`Renderer with id ${renderer.id} failed before rendering started due to an error`, error);
                error.info = { ...error.info, userTestId: eyes.test.userTestId, renderer };
                throw error;
            }
        });
        return Promise.all(promises);
    };
}
exports.makeCheckAndClose = makeCheckAndClose;
