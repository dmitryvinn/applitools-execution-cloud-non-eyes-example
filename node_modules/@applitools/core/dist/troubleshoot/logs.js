"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.structureLogs = exports.parseLogs = void 0;
function parseLogs(logs) {
    const regexp = /^(?<label>[^\s]+) (?:\((?<tags>[^\)]+)\) )?\| (?<timestamp>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)? (?:\[(?<level>[A-Z]+)\s*\])? (?<message>.+)$/;
    const lines = logs.split('\n');
    return lines.reduce((logs, line) => {
        var _a, _b;
        const match = line.match(regexp);
        if (match) {
            logs.push({
                ...match.groups,
                tags: (_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.split(' & ').map(tags => tags.split('/')),
            });
        }
        else if (logs[logs.length - 1]) {
            logs[logs.length - 1].message += line;
        }
        return logs;
    }, []);
}
exports.parseLogs = parseLogs;
function structureLogs(logs) {
    const groups = {};
    logs.forEach(log => {
        var _a;
        const tags = (_a = log.tags) !== null && _a !== void 0 ? _a : [[]];
        tags.forEach(tags => {
            var _a;
            const group = tags.reduce((object, key) => {
                var _a;
                (_a = object[key]) !== null && _a !== void 0 ? _a : (object[key] = {});
                return object[key];
            }, groups);
            (_a = group.logs) !== null && _a !== void 0 ? _a : (group.logs = []);
            group.logs.push(log);
        });
    });
    return groups;
}
exports.structureLogs = structureLogs;
