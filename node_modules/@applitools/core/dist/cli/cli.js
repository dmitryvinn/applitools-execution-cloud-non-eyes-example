#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-console: off */
const core_server_1 = require("../universal/core-server");
const core_server_process_1 = require("../universal/core-server-process");
const logs_1 = require("../troubleshoot/logs");
const yargs_1 = __importDefault(require("yargs"));
const utils = __importStar(require("@applitools/utils"));
yargs_1.default
    .example([
    ['eyes universal', 'Run Eyes Universal server on default port (21077)'],
    ['eyes universal --fork', 'Run Eyes Universal server in a forked process'],
    ['eyes universal --port 8080', 'Run Eyes Universal server on port 8080'],
    ['eyes universal --no-singleton', 'Run Eyes Universal server on a non-singleton mode'],
    ['eyes universal --shutdown-mode stdin', 'Run Eyes Universal server which will close once stdin stream will end'],
    ['eyes check-network', ''],
])
    .command({
    command: 'universal',
    builder: yargs => yargs.options({
        port: {
            description: 'run server on a specific port.',
            type: 'number',
            default: 21077,
        },
        singleton: {
            description: 'runs server on a singleton mode. It will prevent the server to start in case the same server is already started.',
            type: 'boolean',
            default: true,
        },
        fork: {
            description: 'runs server in a forked process.',
            type: 'boolean',
            default: false,
        },
        debug: {
            description: 'runs server in a debug mode.',
            type: 'boolean',
            default: false,
        },
        'port-resolution-mode': {
            describe: 'preferred algorithm to solve port collisions.\n"lazy" mode will not try find free port.\n"random" mode will run on a random port.\n"next" mode will run on next free port after the given one.',
            alias: 'port-resolution',
            type: 'string',
            default: 'next',
        },
        'shutdown-mode': {
            describe: 'preferred algorithm to automatically kill the process.\n"lazy" mode will end the process once the idle timeout ran out after the last client is disconnected from the server.\n"stdin" mode will end the process once its stdin stream got to its end.',
            alias: 'shutdown',
            type: 'string',
            default: 'lazy',
        },
        'idle-timeout': {
            description: 'time in minutes for server to stay responsible in case of idle.',
            type: 'number',
            default: 15,
            coerce: value => value * 60 * 1000,
        },
        cert: {
            description: 'path to the certificate file.',
            alias: 'cert-path',
            type: 'string',
            implies: 'key',
        },
        key: {
            description: 'path to the key file.',
            alias: 'key-path',
            type: 'string',
            implies: 'cert',
        },
        config: {
            description: 'json string to use instead of cli arguments',
            type: 'string',
            coerce: JSON.parse,
        },
    }),
    handler: async (args) => {
        if (args.fork) {
            const { port } = await (0, core_server_process_1.makeCoreServerProcess)({ ...args, fork: false, isProcess: true });
            // eslint-disable-next-line no-console
            console.log(port); // NOTE: this is a part of the generic protocol
        }
        else {
            (0, core_server_1.makeCoreServer)({ ...args, ...args.config, isProcess: true });
        }
    },
})
    .command({
    command: 'logs [input]',
    builder: yargs => yargs.options({
        input: {
            description: 'log input to process',
            type: 'string',
        },
        structure: {
            description: 'group logs by tag names',
            type: 'boolean',
        },
    }),
    handler: async (args) => {
        var _a;
        const input = (_a = args.input) !== null && _a !== void 0 ? _a : (await utils.streams.toBuffer(process.stdin)).toString('utf8');
        const logs = (0, logs_1.parseLogs)(input);
        if (args.structure) {
            console.log(JSON.stringify((0, logs_1.structureLogs)(logs), null, 2));
        }
        else {
            console.log(JSON.stringify(logs, null, 2));
        }
    },
})
    .wrap(yargs_1.default.terminalWidth()).argv;
