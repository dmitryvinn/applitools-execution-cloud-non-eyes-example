"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsonOutput = exports.toXmlOutput = exports.toFlattenedTAPString = exports.toHierarchicTAPString = exports.toFormatterString = void 0;
const OK = 'ok';
const NOT_OK = 'not ok';
function toFormatterString(results, { includeSubTests = true, markNewAsPassed = false } = {}) {
    var _a;
    if (results.length === 0)
        return 'No results found.';
    let formattedString = '[EYES: TEST RESULTS]:\n';
    results.forEach(currentResult => {
        var _a, _b, _c, _d;
        const testTitle = `${currentResult.name} [${(_a = currentResult.hostDisplaySize) === null || _a === void 0 ? void 0 : _a.width}x${(_b = currentResult.hostDisplaySize) === null || _b === void 0 ? void 0 : _b.height}]`;
        let testResult = '';
        if (currentResult.isNew) {
            testResult = markNewAsPassed ? 'Passed' : 'New';
        }
        else if (!currentResult.isDifferent) {
            testResult = 'Passed';
        }
        else {
            const stepsFailed = ((_c = currentResult.mismatches) !== null && _c !== void 0 ? _c : 0) + ((_d = currentResult.missing) !== null && _d !== void 0 ? _d : 0);
            testResult = `Failed ${stepsFailed} of ${currentResult.steps}`;
        }
        formattedString += `${testTitle} - ${testResult}\n`;
        if (includeSubTests) {
            if (currentResult.stepsInfo && currentResult.stepsInfo.length > 0) {
                currentResult.stepsInfo.forEach(currentStep => {
                    const subTestTitle = currentStep.name;
                    const subTestResult = currentStep.isDifferent ? 'Passed' : 'Failed';
                    formattedString += `\t> ${subTestTitle} - ${subTestResult}\n`;
                });
            }
            else {
                formattedString += '\tNo steps exist for this test.\n';
            }
        }
    });
    formattedString += `See details at ${(_a = results[0].appUrls) === null || _a === void 0 ? void 0 : _a.batch}`;
    return formattedString;
}
exports.toFormatterString = toFormatterString;
function toHierarchicTAPString(results, { includeSubTests = true, markNewAsPassed = false } = {}) {
    if (results.length === 0)
        return '';
    let tapString = `1..${results.length}\n`;
    results.forEach((currentResult, index) => {
        if (index > 0)
            tapString += '#\n';
        const tapIndex = index + 1;
        const name = `Test: '${currentResult.name}', Application: '${currentResult.appName}'`;
        if (!currentResult.isDifferent) {
            tapString += `${OK} ${tapIndex} - [PASSED TEST] ${name}\n`;
        }
        else if (currentResult.isNew) {
            // Test did not pass (might also be a new test).
            // New test
            const newResult = markNewAsPassed ? OK : NOT_OK;
            tapString += `${newResult} ${tapIndex} - [NEW TEST] ${name}\n`;
        }
        else {
            // Failed / Aborted test.
            tapString += `${NOT_OK} ${tapIndex} - `;
            if (currentResult.isAborted) {
                tapString += `[ABORTED TEST] ${name}\n`;
            }
            else {
                tapString += `[FAILED TEST] ${name}\n`;
            }
            tapString += `#\tMismatches: ${currentResult.mismatches}\n`;
        }
        const url = currentResult.appUrls && currentResult.appUrls.session
            ? currentResult.appUrls.session
            : "No URL (session didn't start).";
        tapString += `#\tTest url: ${url}\n`;
        tapString += `#\tBrowser: ${currentResult.hostApp}, Viewport: ${currentResult.hostDisplaySize.width}X${currentResult.hostDisplaySize.width}\n`;
        if (includeSubTests) {
            if (currentResult.stepsInfo && currentResult.stepsInfo.length > 0) {
                tapString += `\t1..${currentResult.stepsInfo.length}\n`;
                currentResult.stepsInfo.forEach(currentStep => {
                    var _a;
                    tapString += '\t';
                    tapString += currentStep.isDifferent ? NOT_OK : OK;
                    tapString += ` '${currentStep.name}', URL: ${(_a = currentStep.appUrls) === null || _a === void 0 ? void 0 : _a.step}\n`;
                });
            }
            else {
                tapString += '\tNo steps exist for this test.\n';
            }
        }
    });
    return tapString;
}
exports.toHierarchicTAPString = toHierarchicTAPString;
function toFlattenedTAPString(results, { markNewAsPassed = false } = {}) {
    let tapString = '';
    let stepsCounter = 0;
    // We'll add the TAP plan at the beginning, after we calculate the total number of steps.
    results.forEach((currentResult, index) => {
        tapString += '#\n';
        const tapIndex = index + 1;
        const name = `Test: '${currentResult.name}', Application: '${currentResult.appName}'`;
        if (!currentResult.isDifferent) {
            tapString += `# ${OK} ${tapIndex} - [PASSED TEST] ${name}\n`;
        }
        else if (currentResult.isNew) {
            // Test did not pass (might also be a new test).
            // New test
            const newResult = markNewAsPassed ? OK : NOT_OK;
            tapString += `# ${newResult} ${tapIndex} - [NEW TEST] ${name}\n`;
        }
        else {
            // Failed / Aborted test.
            tapString += `# ${NOT_OK} ${tapIndex} - `;
            if (currentResult.isAborted) {
                tapString += `[ABORTED TEST] ${name}\n`;
            }
            else {
                tapString += `[FAILED TEST] ${name}\n`;
            }
            tapString += `#\tMismatches: ${currentResult.mismatches}\n`;
        }
        const url = currentResult.appUrls && currentResult.appUrls.session
            ? currentResult.appUrls.session
            : "No URL (session didn't start).";
        tapString += `#\tTest url: ${url}\n`;
        if (currentResult.stepsInfo && currentResult.stepsInfo.length > 0) {
            currentResult.stepsInfo.forEach(currentStep => {
                var _a;
                stepsCounter += 1;
                tapString += currentStep.isDifferent ? NOT_OK : OK;
                tapString += ` ${stepsCounter} '${currentStep.name}', URL: ${(_a = currentStep.appUrls) === null || _a === void 0 ? void 0 : _a.step}\n`;
            });
        }
        else {
            tapString += '#\tNo steps exist for this test.\n';
        }
    });
    if (stepsCounter > 0) {
        tapString = `1..${stepsCounter}\n${tapString}`;
    }
    return tapString;
}
exports.toFlattenedTAPString = toFlattenedTAPString;
function toXmlOutput(results, { totalTime } = {}) {
    const suiteName = 'Eyes Test Suite';
    let output = `<?xml version="1.0" encoding="UTF-8" ?>`;
    output += `\n<testsuite name="${suiteName}" tests="${results.length}" time="${totalTime}">`;
    results.forEach(result => {
        var _a;
        output += `\n<testcase name="${result.name}"${result.duration ? ` time="${result.duration}"` : ''}>`;
        const properties = {};
        if (result.hostOS)
            properties.hostOS = result.hostOS;
        if (result.hostApp)
            properties.hostApp = result.hostApp;
        if (result.hostDisplaySize)
            properties.viewportSize = `${result.hostDisplaySize.width}x${result.hostDisplaySize.height}`;
        if (properties.hostOS || properties.hostApp || properties.viewportSize) {
            output += `\n<properties>`;
            for (const [name, value] of Object.entries(properties)) {
                output += `\n<property name="${name}" value="${value}"/>`;
            }
            output += `\n</properties>`;
        }
        if (result.isDifferent) {
            output += `\n<failure>`;
            output += `\nDifference found. See ${(_a = result.appUrls) === null || _a === void 0 ? void 0 : _a.batch} for details.`;
            output += `\n</failure>`;
        }
        else if (result.isAborted) {
            output += `\n<failure>`;
            output += `\nTest aborted.`;
            output += `\n</failure>`;
        }
        output += `\n</testcase>`;
    });
    output += `\n</testsuite>`;
    return output;
}
exports.toXmlOutput = toXmlOutput;
function toJsonOutput(results, space) {
    return JSON.stringify(results, null, space);
}
exports.toJsonOutput = toJsonOutput;
